{"version":3,"file":"dispatchEvent.mjs","sources":["../../../../../../src/inAppMessaging/providers/pinpoint/apis/dispatchEvent.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport flatten from 'lodash/flatten.js';\nimport { defaultStorage } from '@aws-amplify/core';\nimport { notifyEventListeners } from '../../../../eventListeners';\nimport { assertServiceError, } from '../../../errors';\nimport { assertIsInitialized } from '../../../utils';\nimport { PINPOINT_KEY_PREFIX, STORAGE_KEY_SUFFIX, getConflictHandler, processInAppMessages, } from '../utils';\n/**\n * Triggers an In-App message to be displayed. Use this after your campaigns have been synced to the device using\n * {@link syncMessages}. Based on the messages synced and the event passed to this API, it triggers the display\n * of the In-App message that meets the criteria.\n *\n * @remark\n * If an event would trigger multiple messages, the message closest to expiry will be chosen by default.\n * To change this behavior, you can use the {@link setConflictHandler} API to provide\n * your own logic for resolving message conflicts.\n *\n * @param input The input object that holds the event to be dispatched.\n *\n * @throws validation: {@link InAppMessagingValidationErrorCode} - Thrown when the provided parameters or library\n * configuration is incorrect, or if In App messaging hasn't been initialized.\n * @throws service exceptions - Thrown when the underlying Pinpoint service returns an error.\n *\n * @returns A promise that will resolve when the operation is complete.\n *\n * @example\n * ```ts\n * // Sync message before disptaching an event\n * await syncMessages();\n *\n * // Dispatch an event\n * await dispatchEvent({ name: 'test_event' });\n * ```\n */\nexport async function dispatchEvent(input) {\n    assertIsInitialized();\n    try {\n        const key = `${PINPOINT_KEY_PREFIX}${STORAGE_KEY_SUFFIX}`;\n        const cachedMessages = await defaultStorage.getItem(key);\n        const messages = await processInAppMessages(cachedMessages ? JSON.parse(cachedMessages) : [], input);\n        const flattenedMessages = flatten(messages);\n        if (flattenedMessages.length > 0) {\n            const conflictHandler = getConflictHandler();\n            notifyEventListeners('messageReceived', conflictHandler(flattenedMessages));\n        }\n    }\n    catch (error) {\n        assertServiceError(error);\n        throw error;\n    }\n}\n"],"names":[],"mappings":";;;;;;;;;;;AAAA;AACA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,eAAe,aAAa,CAAC,KAAK,EAAE;AAC3C,IAAI,mBAAmB,EAAE,CAAC;AAC1B,IAAI,IAAI;AACR,QAAQ,MAAM,GAAG,GAAG,CAAC,EAAE,mBAAmB,CAAC,EAAE,kBAAkB,CAAC,CAAC,CAAC;AAClE,QAAQ,MAAM,cAAc,GAAG,MAAM,cAAc,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC;AACjE,QAAQ,MAAM,QAAQ,GAAG,MAAM,oBAAoB,CAAC,cAAc,GAAG,IAAI,CAAC,KAAK,CAAC,cAAc,CAAC,GAAG,EAAE,EAAE,KAAK,CAAC,CAAC;AAC7G,QAAQ,MAAM,iBAAiB,GAAG,OAAO,CAAC,QAAQ,CAAC,CAAC;AACpD,QAAQ,IAAI,iBAAiB,CAAC,MAAM,GAAG,CAAC,EAAE;AAC1C,YAAY,MAAM,eAAe,GAAG,kBAAkB,EAAE,CAAC;AACzD,YAAY,oBAAoB,CAAC,iBAAiB,EAAE,eAAe,CAAC,iBAAiB,CAAC,CAAC,CAAC;AACxF,SAAS;AACT,KAAK;AACL,IAAI,OAAO,KAAK,EAAE;AAClB,QAAQ,kBAAkB,CAAC,KAAK,CAAC,CAAC;AAClC,QAAQ,MAAM,KAAK,CAAC;AACpB,KAAK;AACL;;;;"}