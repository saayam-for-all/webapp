import { MixedType, arrayTypeSchemaSpec } from './MixedType';
export class ArrayType extends MixedType {
    constructor(errorMessage) {
        super('array');
        this.isArrayTypeNested = false;
        super.pushRule({
            onValid: v => {
                // Skip array type check for nested array elements
                if (this.isArrayTypeNested) {
                    return true;
                }
                return Array.isArray(v);
            },
            errorMessage: errorMessage || this.locale.type
        });
    }
    rangeLength(minLength, maxLength, errorMessage = this.locale.rangeLength) {
        super.pushRule({
            onValid: (value) => value.length >= minLength && value.length <= maxLength,
            errorMessage,
            params: { minLength, maxLength }
        });
        return this;
    }
    minLength(minLength, errorMessage = this.locale.minLength) {
        super.pushRule({
            onValid: value => value.length >= minLength,
            errorMessage,
            params: { minLength }
        });
        return this;
    }
    maxLength(maxLength, errorMessage = this.locale.maxLength) {
        super.pushRule({
            onValid: value => value.length <= maxLength,
            errorMessage,
            params: { maxLength }
        });
        return this;
    }
    unrepeatable(errorMessage = this.locale.unrepeatable) {
        super.pushRule({
            onValid: items => {
                const hash = {};
                for (const i in items) {
                    if (hash[items[i]]) {
                        return false;
                    }
                    hash[items[i]] = true;
                }
                return true;
            },
            errorMessage
        });
        return this;
    }
    of(type) {
        this[arrayTypeSchemaSpec] = type;
        // Mark inner ArrayType as nested when dealing with nested arrays
        if (type instanceof ArrayType) {
            type.isArrayTypeNested = true;
        }
        super.pushRule({
            onValid: (items, data, fieldName) => {
                // For non-array values in nested arrays, pass directly to inner type validation
                if (!Array.isArray(items) && this.isArrayTypeNested) {
                    return type.check(items, data, fieldName);
                }
                // For non-array values in non-nested arrays, return array type error
                if (!Array.isArray(items)) {
                    return {
                        hasError: true,
                        errorMessage: this.locale.type
                    };
                }
                const checkResults = items.map((value, index) => {
                    const name = Array.isArray(fieldName)
                        ? [...fieldName, `[${index}]`]
                        : [fieldName, `[${index}]`];
                    return type.check(value, data, name);
                });
                const hasError = !!checkResults.find(item => item === null || item === void 0 ? void 0 : item.hasError);
                return {
                    hasError,
                    array: checkResults
                };
            }
        });
        return this;
    }
}
export default function getArrayType(errorMessage) {
    return new ArrayType(errorMessage);
}
//# sourceMappingURL=ArrayType.js.map