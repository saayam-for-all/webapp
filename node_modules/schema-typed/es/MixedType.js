import { checkRequired, createValidator, createValidatorAsync, isEmpty, shallowEqual, formatErrorMessage, get } from './utils';
import { joinName } from './utils/formatErrorMessage';
import locales from './locales';
export const schemaSpecKey = 'objectTypeSchemaSpec';
export const arrayTypeSchemaSpec = 'arrayTypeSchemaSpec';
/**
 * Get the field type from the schema object
 */
export function getFieldType(schemaSpec, fieldName, nestedObject) {
    if (nestedObject) {
        const namePath = fieldName.split('.');
        const currentField = namePath[0];
        const arrayMatch = currentField.match(/(\w+)\[(\d+)\]/);
        if (arrayMatch) {
            const [, arrayField] = arrayMatch;
            const type = schemaSpec[arrayField];
            if (type === null || type === void 0 ? void 0 : type[arrayTypeSchemaSpec]) {
                // If there are remaining paths and the type is ObjectType (has schemaSpecKey)
                if (namePath.length > 1 && type[arrayTypeSchemaSpec][schemaSpecKey]) {
                    return getFieldType(type[arrayTypeSchemaSpec][schemaSpecKey], namePath.slice(1).join('.'), true);
                }
                // Otherwise return the array element type directly
                return type[arrayTypeSchemaSpec];
            }
            return type;
        }
        const joinedPath = namePath.join(`.${schemaSpecKey}.`);
        return get(schemaSpec, joinedPath);
    }
    return schemaSpec === null || schemaSpec === void 0 ? void 0 : schemaSpec[fieldName];
}
/**
 * Get the field value from the data object
 */
export function getFieldValue(data, fieldName, nestedObject) {
    return nestedObject ? get(data, fieldName) : data === null || data === void 0 ? void 0 : data[fieldName];
}
export class MixedType {
    constructor(name) {
        this.required = false;
        this.requiredMessage = '';
        this.trim = false;
        this.emptyAllowed = false;
        this.rules = [];
        this.priorityRules = [];
        // The field name that depends on the verification of other fields
        this.otherFields = [];
        this.proxyOptions = {};
        this.$typeName = name;
        this.locale = Object.assign(name ? locales[name] : {}, locales.mixed);
    }
    setSchemaOptions(schemaSpec, value) {
        this.$schemaSpec = schemaSpec;
        this.value = value;
    }
    check(value = this.value, data, fieldName) {
        if (this.required && !checkRequired(value, this.trim, this.emptyAllowed)) {
            return {
                hasError: true,
                errorMessage: formatErrorMessage(this.requiredMessage, {
                    name: this.fieldLabel || joinName(fieldName)
                })
            };
        }
        const validator = createValidator(data, fieldName, this.fieldLabel);
        const checkResult = validator(value, this.priorityRules);
        // If the priority rule fails, return the result directly
        if (checkResult) {
            return checkResult;
        }
        if (!this.required && isEmpty(value)) {
            return { hasError: false };
        }
        return validator(value, this.rules) || { hasError: false };
    }
    checkAsync(value = this.value, data, fieldName) {
        if (this.required && !checkRequired(value, this.trim, this.emptyAllowed)) {
            return Promise.resolve({
                hasError: true,
                errorMessage: formatErrorMessage(this.requiredMessage, {
                    name: this.fieldLabel || joinName(fieldName)
                })
            });
        }
        const validator = createValidatorAsync(data, fieldName, this.fieldLabel);
        return new Promise(resolve => validator(value, this.priorityRules)
            .then((checkResult) => {
            // If the priority rule fails, return the result directly
            if (checkResult) {
                resolve(checkResult);
            }
        })
            .then(() => {
            if (!this.required && isEmpty(value)) {
                resolve({ hasError: false });
            }
        })
            .then(() => validator(value, this.rules))
            .then((checkResult) => {
            if (checkResult) {
                resolve(checkResult);
            }
            resolve({ hasError: false });
        }));
    }
    pushRule(rule) {
        var _a, _b;
        const { onValid, errorMessage, priority, params } = rule;
        const nextRule = {
            onValid,
            params,
            isAsync: rule.isAsync,
            errorMessage: errorMessage || ((_b = (_a = this.rules) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.errorMessage)
        };
        if (priority) {
            this.priorityRules.push(nextRule);
        }
        else {
            this.rules.push(nextRule);
        }
    }
    addRule(onValid, errorMessage, priority) {
        this.pushRule({ onValid, errorMessage, priority });
        return this;
    }
    addAsyncRule(onValid, errorMessage, priority) {
        this.pushRule({ onValid, isAsync: true, errorMessage, priority });
        return this;
    }
    isRequired(errorMessage = this.locale.isRequired, trim = true) {
        this.required = true;
        this.trim = trim;
        this.requiredMessage = errorMessage;
        return this;
    }
    isRequiredOrEmpty(errorMessage = this.locale.isRequiredOrEmpty, trim = true) {
        this.required = true;
        this.trim = trim;
        this.emptyAllowed = true;
        this.requiredMessage = errorMessage;
        return this;
    }
    /**
     * Define data verification rules based on conditions.
     * @param condition
     * @example
     *
     * ```js
     * SchemaModel({
     *   option: StringType().isOneOf(['a', 'b', 'other']),
     *   other: StringType().when(schema => {
     *     const { value } = schema.option;
     *     return value === 'other' ? StringType().isRequired('Other required') : StringType();
     *   })
     * });
     * ```
     */
    when(condition) {
        this.addRule((value, data, fieldName) => {
            return condition(this.$schemaSpec).check(value, data, fieldName);
        }, undefined, true);
        return this;
    }
    /**
     * Check if the value is equal to the value of another field.
     * @example
     *
     * ```js
     * SchemaModel({
     *   password: StringType().isRequired(),
     *   confirmPassword: StringType().equalTo('password').isRequired()
     * });
     * ```
     */
    equalTo(fieldName, errorMessage = this.locale.equalTo) {
        const errorMessageFunc = () => {
            const type = getFieldType(this.$schemaSpec, fieldName, true);
            return formatErrorMessage(errorMessage, { toFieldName: (type === null || type === void 0 ? void 0 : type.fieldLabel) || fieldName });
        };
        this.addRule((value, data) => {
            return shallowEqual(value, get(data, fieldName));
        }, errorMessageFunc);
        return this;
    }
    /**
     * After the field verification passes, proxy verification of other fields.
     * @param options.checkIfValueExists When the value of other fields exists, the verification is performed (default: false)
     * @example
     *
     * ```js
     * SchemaModel({
     *   password: StringType().isRequired().proxy(['confirmPassword']),
     *   confirmPassword: StringType().equalTo('password').isRequired()
     * });
     * ```
     */
    proxy(fieldNames, options) {
        this.otherFields = fieldNames;
        this.proxyOptions = options || {};
        return this;
    }
    /**
     * Overrides the key name in error messages.
     *
     * @example
     * ```js
     * SchemaModel({
     *  first_name: StringType().label('First name'),
     *  age: NumberType().label('Age')
     * });
     * ```
     */
    label(label) {
        this.fieldLabel = label;
        return this;
    }
}
export default function getMixedType() {
    return new MixedType();
}
//# sourceMappingURL=MixedType.js.map