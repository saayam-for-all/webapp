import { SchemaDeclaration, SchemaCheckResult, CheckResult, PlainObject } from './types';
interface CheckOptions {
    /**
     * Check for nested object
     */
    nestedObject?: boolean;
}
export declare class Schema<DataType = any, ErrorMsgType = string> {
    readonly $spec: SchemaDeclaration<DataType, ErrorMsgType>;
    private data;
    private checkResult;
    constructor(schema: SchemaDeclaration<DataType, ErrorMsgType>);
    private getFieldType;
    private setFieldCheckResult;
    private setSchemaOptionsForAllType;
    /**
     * Get the check result of the schema
     * @returns CheckResult<ErrorMsgType | string>
     */
    getCheckResult(path?: string, result?: SchemaCheckResult<DataType, ErrorMsgType>): CheckResult<ErrorMsgType | string>;
    /**
     * Get the error messages of the schema
     */
    getErrorMessages(path?: string, result?: SchemaCheckResult<DataType, ErrorMsgType>): (string | ErrorMsgType)[];
    /**
     * Get all the keys of the schema
     */
    getKeys(): string[];
    /**
     * Get the schema specification
     */
    getSchemaSpec(): SchemaDeclaration<DataType, ErrorMsgType>;
    checkForField<T extends keyof DataType>(fieldName: T, data: DataType, options?: CheckOptions): CheckResult<ErrorMsgType | string>;
    checkForFieldAsync<T extends keyof DataType>(fieldName: T, data: DataType, options?: CheckOptions): Promise<CheckResult<ErrorMsgType | string>>;
    check<T extends keyof DataType>(data: DataType): SchemaCheckResult<DataType, ErrorMsgType>;
    checkAsync<T extends keyof DataType>(data: DataType): Promise<SchemaCheckResult<DataType, ErrorMsgType>>;
}
export declare function SchemaModel<DataType = PlainObject, ErrorMsgType = string>(o: SchemaDeclaration<DataType, ErrorMsgType>): Schema<DataType, ErrorMsgType>;
export declare namespace SchemaModel {
    var combine: <DataType = any, ErrorMsgType = string>(...specs: Schema<any, ErrorMsgType>[]) => Schema<DataType, ErrorMsgType>;
}
export {};
