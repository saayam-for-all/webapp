"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SchemaModel = exports.Schema = void 0;
const MixedType_1 = require("./MixedType");
const utils_1 = require("./utils");
class Schema {
    constructor(schema) {
        this.checkResult = {};
        this.$spec = schema;
    }
    getFieldType(fieldName, nestedObject) {
        return (0, MixedType_1.getFieldType)(this.$spec, fieldName, nestedObject);
    }
    setFieldCheckResult(fieldName, checkResult, nestedObject) {
        if (nestedObject) {
            const namePath = fieldName.split('.').join('.object.');
            (0, utils_1.set)(this.checkResult, namePath, checkResult);
            return;
        }
        this.checkResult[fieldName] = checkResult;
    }
    setSchemaOptionsForAllType(data) {
        if (data === this.data) {
            return;
        }
        Object.entries(this.$spec).forEach(([key, type]) => {
            type.setSchemaOptions(this.$spec, data === null || data === void 0 ? void 0 : data[key]);
        });
        this.data = data;
    }
    /**
     * Get the check result of the schema
     * @returns CheckResult<ErrorMsgType | string>
     */
    getCheckResult(path, result = this.checkResult) {
        if (path) {
            return (result === null || result === void 0 ? void 0 : result[path]) || (0, utils_1.get)(result, (0, utils_1.pathTransform)(path)) || { hasError: false };
        }
        return result;
    }
    /**
     * Get the error messages of the schema
     */
    getErrorMessages(path, result = this.checkResult) {
        let messages = [];
        if (path) {
            const { errorMessage, object, array } = (result === null || result === void 0 ? void 0 : result[path]) || (0, utils_1.get)(result, (0, utils_1.pathTransform)(path)) || {};
            if (errorMessage) {
                messages = [errorMessage];
            }
            else if (object) {
                messages = Object.keys(object).map(key => { var _a; return (_a = object[key]) === null || _a === void 0 ? void 0 : _a.errorMessage; });
            }
            else if (array) {
                messages = array.map(item => item === null || item === void 0 ? void 0 : item.errorMessage);
            }
        }
        else {
            messages = Object.keys(result).map(key => { var _a; return (_a = result[key]) === null || _a === void 0 ? void 0 : _a.errorMessage; });
        }
        return messages.filter(Boolean);
    }
    /**
     * Get all the keys of the schema
     */
    getKeys() {
        return Object.keys(this.$spec);
    }
    /**
     * Get the schema specification
     */
    getSchemaSpec() {
        return this.$spec;
    }
    checkForField(fieldName, data, options = {}) {
        var _a;
        this.setSchemaOptionsForAllType(data);
        const { nestedObject } = options;
        const fieldChecker = this.getFieldType(fieldName, nestedObject);
        if (!fieldChecker) {
            // fieldValue can be anything if no schema defined
            return { hasError: false };
        }
        const fieldValue = (0, MixedType_1.getFieldValue)(data, fieldName, nestedObject);
        const checkResult = fieldChecker.check(fieldValue, data, fieldName);
        this.setFieldCheckResult(fieldName, checkResult, nestedObject);
        if (!checkResult.hasError) {
            const { checkIfValueExists } = fieldChecker.proxyOptions;
            // Check other fields if the field depends on them for validation
            (_a = fieldChecker.otherFields) === null || _a === void 0 ? void 0 : _a.forEach((field) => {
                if (checkIfValueExists) {
                    if (!(0, utils_1.isEmpty)((0, MixedType_1.getFieldValue)(data, field, nestedObject))) {
                        this.checkForField(field, data, options);
                    }
                    return;
                }
                this.checkForField(field, data, options);
            });
        }
        return checkResult;
    }
    checkForFieldAsync(fieldName, data, options = {}) {
        this.setSchemaOptionsForAllType(data);
        const { nestedObject } = options;
        const fieldChecker = this.getFieldType(fieldName, nestedObject);
        if (!fieldChecker) {
            // fieldValue can be anything if no schema defined
            return Promise.resolve({ hasError: false });
        }
        const fieldValue = (0, MixedType_1.getFieldValue)(data, fieldName, nestedObject);
        const checkResult = fieldChecker.checkAsync(fieldValue, data, fieldName);
        return checkResult.then(async (result) => {
            var _a;
            this.setFieldCheckResult(fieldName, result, nestedObject);
            if (!result.hasError) {
                const { checkIfValueExists } = fieldChecker.proxyOptions;
                const checkAll = [];
                // Check other fields if the field depends on them for validation
                (_a = fieldChecker.otherFields) === null || _a === void 0 ? void 0 : _a.forEach((field) => {
                    if (checkIfValueExists) {
                        if (!(0, utils_1.isEmpty)((0, MixedType_1.getFieldValue)(data, field, nestedObject))) {
                            checkAll.push(this.checkForFieldAsync(field, data, options));
                        }
                        return;
                    }
                    checkAll.push(this.checkForFieldAsync(field, data, options));
                });
                await Promise.all(checkAll);
            }
            return result;
        });
    }
    check(data) {
        const checkResult = {};
        Object.keys(this.$spec).forEach(key => {
            if (typeof data === 'object') {
                checkResult[key] = this.checkForField(key, data);
            }
        });
        return checkResult;
    }
    checkAsync(data) {
        const checkResult = {};
        const promises = [];
        const keys = [];
        Object.keys(this.$spec).forEach((key) => {
            keys.push(key);
            promises.push(this.checkForFieldAsync(key, data));
        });
        return Promise.all(promises).then(values => {
            for (let i = 0; i < values.length; i += 1) {
                checkResult[keys[i]] = values[i];
            }
            return checkResult;
        });
    }
}
exports.Schema = Schema;
function SchemaModel(o) {
    return new Schema(o);
}
exports.SchemaModel = SchemaModel;
SchemaModel.combine = function combine(...specs) {
    return new Schema(specs
        .map(model => model.$spec)
        .reduce((accumulator, currentValue) => Object.assign(accumulator, currentValue), {}));
};
//# sourceMappingURL=Schema.js.map