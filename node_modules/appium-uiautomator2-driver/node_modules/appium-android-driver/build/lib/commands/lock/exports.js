"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.lock = lock;
exports.isLocked = isLocked;
exports.unlock = unlock;
exports.mobileUnlock = mobileUnlock;
exports.unlockWithOptions = unlockWithOptions;
const bluebird_1 = __importDefault(require("bluebird"));
const helpers_1 = require("./helpers");
const lodash_1 = __importDefault(require("lodash"));
/**
 * @this {AndroidDriver}
 * @param {number} [seconds]
 * @returns {Promise<void>}
 */
async function lock(seconds) {
    await this.adb.lock();
    if (Number.isNaN(seconds)) {
        return;
    }
    const floatSeconds = parseFloat(String(seconds));
    if (floatSeconds <= 0) {
        return;
    }
    await bluebird_1.default.delay(1000 * floatSeconds);
    await this.unlock();
}
/**
 * @this {AndroidDriver}
 * @returns {Promise<boolean>}
 */
async function isLocked() {
    return await this.adb.isScreenLocked();
}
/**
 * @this {AndroidDriver}
 * @returns {Promise<void>}
 */
async function unlock() {
    await unlockWithOptions.bind(this)();
}
/**
 * @this {AndroidDriver}
 * @param {string} [key] The unlock key. The value of this key depends on the actual unlock type and
 * could be a pin/password/pattern value or a biometric finger id.
 * If not provided then the corresponding value from session capabilities is
 * used.
 * @param {import('../types').UnlockType} [type] The unlock type.
 * If not provided then the corresponding value from session capabilities is used.
 * @param {string} [strategy] Setting it to 'uiautomator' will enforce the driver to avoid using special
 * ADB shortcuts in order to speed up the unlock procedure.
 * 'uiautomator' by default.
 * @param {number} [timeoutMs] The maximum time in milliseconds to wait until the screen gets unlocked
 * 2000ms byde fault.
 * @returns {Promise<void>}
 */
async function mobileUnlock(key, type, strategy, timeoutMs) {
    if (!key && !type) {
        await this.unlock();
    }
    else {
        await unlockWithOptions.bind(this)({
            unlockKey: key,
            unlockType: type,
            unlockStrategy: strategy,
            unlockSuccessTimeout: timeoutMs,
        });
    }
}
// #region Internal Helpers
/**
 * @this {AndroidDriver}
 * @param {AndroidDriverCaps?} [caps=null]
 * @returns {Promise<void>}
 */
async function unlockWithOptions(caps = null) {
    if (!(await this.adb.isScreenLocked())) {
        this.log.info('Screen already unlocked, doing nothing');
        return;
    }
    const capabilities = caps ?? this.opts;
    this.log.debug('Screen is locked, trying to unlock');
    if (!capabilities.unlockType && !capabilities.unlockKey) {
        this.log.info(`Neither 'unlockType' nor 'unlockKey' capability is provided. ` +
            `Assuming the device is locked with a simple lock screen.`);
        await this.adb.dismissKeyguard();
        return;
    }
    const { unlockType, unlockKey, unlockStrategy, unlockSuccessTimeout } = (0, helpers_1.validateUnlockCapabilities)(capabilities);
    if (unlockKey &&
        unlockType !== helpers_1.FINGERPRINT_UNLOCK &&
        (lodash_1.default.isNil(unlockStrategy) || lodash_1.default.toLower(unlockStrategy) === 'locksettings') &&
        (await this.adb.isLockManagementSupported())) {
        await helpers_1.fastUnlock.bind(this)({
            credential: unlockKey,
            credentialType: (0, helpers_1.toCredentialType)(/** @type {import('../types').UnlockType} */ (unlockType)),
        });
    }
    else {
        const unlockMethod = {
            [helpers_1.PIN_UNLOCK]: helpers_1.pinUnlock,
            [helpers_1.PIN_UNLOCK_KEY_EVENT]: helpers_1.pinUnlockWithKeyEvent,
            [helpers_1.PASSWORD_UNLOCK]: helpers_1.passwordUnlock,
            [helpers_1.PATTERN_UNLOCK]: helpers_1.patternUnlock,
            [helpers_1.FINGERPRINT_UNLOCK]: helpers_1.fingerprintUnlock,
        }[unlockType];
        await unlockMethod.bind(this)(capabilities);
    }
    await helpers_1.verifyUnlock.bind(this)(unlockSuccessTimeout);
}
// #endregion
/**
 * @typedef {import('@appium/types').Capabilities<import('../../constraints').AndroidDriverConstraints>} AndroidDriverCaps
 * @typedef {import('../../driver').AndroidDriver} AndroidDriver
 */
//# sourceMappingURL=exports.js.map