"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.IosSetup = void 0;
const inquirer_1 = require("inquirer");
const utils_1 = require("../../utils");
const constants_1 = require("./constants");
const ansi_colors_1 = __importDefault(require("ansi-colors"));
const child_process_1 = require("child_process");
const boxen_1 = __importDefault(require("boxen"));
const logger_1 = __importDefault(require("../../logger"));
class IosSetup {
    options;
    cwd;
    platform;
    constructor(options, cwd = process.cwd()) {
        this.options = options;
        this.cwd = cwd;
        this.platform = (0, utils_1.getPlatformName)();
    }
    async run() {
        let result = true;
        const allAvailableOptions = this.getAllAvailableOptions();
        const unknownOptions = Object.keys(this.options).filter((option) => !allAvailableOptions.includes(option));
        if (this.options.help || unknownOptions.length) {
            this.showHelp(unknownOptions);
            return this.options.help === true;
        }
        if (this.platform !== 'mac') {
            logger_1.default.log('Only macOS is supported');
            return false;
        }
        const setupConfigs = await this.getSetupConfigs(this.options);
        const missingRequirements = this.verifySetup(setupConfigs);
        if (this.options.setup) {
            result = await this.setupIos(setupConfigs, missingRequirements);
        }
        else if (missingRequirements.length) {
            result = false;
        }
        return result;
    }
    getConfigFromOptions(options) {
        const configs = {};
        if (options.mode && typeof options.mode !== 'boolean') {
            const realMode = options.mode.includes('real');
            const simulatorMode = options.mode.includes('simulator');
            if (realMode && simulatorMode) {
                configs.mode = 'both';
            }
            else if (realMode) {
                configs.mode = 'real';
            }
            else if (simulatorMode) {
                configs.mode = 'simulator';
            }
        }
        return configs;
    }
    async getSetupConfigs(options) {
        const configs = this.getConfigFromOptions(options);
        return await (0, inquirer_1.prompt)(constants_1.SETUP_CONFIG_QUES, configs);
    }
    verifySetup(setupConfigs) {
        const missingRequirements = [];
        if (setupConfigs.mode === 'simulator' || setupConfigs.mode === 'both') {
            logger_1.default.log('\nVerifying the setup requirements for simulators ...');
            try {
                (0, child_process_1.execSync)('/usr/bin/xcodebuild -version', {
                    stdio: 'pipe'
                });
                logger_1.default.log(`  ${ansi_colors_1.default.green((0, utils_1.symbols)().ok)} Xcode is installed in your machine\n`);
                logger_1.default.log((0, boxen_1.default)('Run the following command to get the list of simulators\n' +
                    ansi_colors_1.default.cyan.italic('xcrun simctl list devices') + '\n' +
                    `\nAnd then update ${ansi_colors_1.default.cyan('safari:deviceName')} (eg: 'iphone 13') and ${ansi_colors_1.default.cyan('safari:platformVersion')} (eg: '15.0') in nightwatch configuration for ${ansi_colors_1.default.gray.italic('ios.simulator.safari')} environment accordingly.`, { padding: 1 }));
            }
            catch (error) {
                logger_1.default.log(`  ${ansi_colors_1.default.red((0, utils_1.symbols)().ok)} Xcode is not installed.`);
                missingRequirements.push('Xcode is not installed');
            }
        }
        if (setupConfigs.mode === 'real' || setupConfigs.mode === 'both') {
            logger_1.default.log('\nVerifying the setup requirements for real devices...');
            try {
                // eslint-disable-next-line
                const stdout = (0, child_process_1.execSync)("system_profiler SPUSBDataType | sed -n '/iPhone/,/Serial/p' | grep 'Serial Number:' | awk -F ': ' '{print $2}'", {
                    stdio: 'pipe'
                });
                if (stdout.toString() !== '') {
                    logger_1.default.log((0, boxen_1.default)(ansi_colors_1.default.white(`Update ${ansi_colors_1.default.cyan('UDID')} in nightwatch configuration for ${ansi_colors_1.default.gray.italic('ios.real.safari')} environment.`) +
                        '\nUDID: ' +
                        ansi_colors_1.default.cyan((0, utils_1.iosRealDeviceUDID)(stdout.toString())), { padding: 1 }));
                }
                else {
                    throw 'Device is not connected';
                }
            }
            catch (error) {
                logger_1.default.log(`  ${ansi_colors_1.default.red((0, utils_1.symbols)().fail)} Device is either not connected or turned off.`);
                missingRequirements.push('Device is not connected');
            }
        }
        if (missingRequirements.length === 0) {
            logger_1.default.log('\nGreat! All the requirements are being met.');
            if (setupConfigs.mode === 'real') {
                logger_1.default.log('You can go ahead and run your tests now on your iOS device.');
            }
            else if (setupConfigs.mode === 'simulator') {
                logger_1.default.log('You can go ahead and run your tests now on an iOS simulator.');
            }
            else {
                logger_1.default.log('You can go ahead and run your tests now on an iOS device/simulator.');
            }
        }
        else if (!this.options.setup) {
            logger_1.default.log(`\nSome requirements are missing: ${missingRequirements.join(', ')}`);
            logger_1.default.log(`Please use ${ansi_colors_1.default.magenta('--setup')} flag with the command to install all the missing requirements.`);
        }
        return missingRequirements;
    }
    async setupIos(setupConfigs, missingRequirements) {
        if (missingRequirements.length === 0) {
            return true;
        }
        const result = { simulator: true, real: true };
        if (setupConfigs.mode === 'simulator' || setupConfigs.mode === 'both') {
            if (missingRequirements.includes('Xcode is not installed')) {
                logger_1.default.log('\nSetting up missing requirements for iOS simulator...');
                logger_1.default.log((0, boxen_1.default)(`${ansi_colors_1.default.cyan('If Xcode is already installed : ')}` +
                    `${ansi_colors_1.default.white('\n  1. Run the following after changing the Xcode app name in the command ')}` +
                    `\n     ${ansi_colors_1.default.grey.italic('sudo xcode-select -switch /Applications/Xcode_x_x.app')}\n` +
                    `${ansi_colors_1.default.cyan('\nIf Xcode is not installed : ')}` +
                    `${ansi_colors_1.default.green('\n  [Easiest Option] : Download via the App Store for the latest version')}` +
                    `${ansi_colors_1.default.white('\n      1. Open the App Store on your mac and Sign in with your Apple credentials')}` +
                    `${ansi_colors_1.default.white('\n      2. Search for Xcode & click install or update. That\'s it!!')}\n` +
                    `${ansi_colors_1.default.green('\n  [Preferred Option] : Download via the Developer site for a specific version')}` +
                    `${ansi_colors_1.default.white(`\n      1. Navigate to this URL ${ansi_colors_1.default.grey.italic('https://developer.apple.com/download/more/')}`)}` +
                    `${ansi_colors_1.default.white('\n      2. Sign in with your Apple credentials')}` +
                    `${ansi_colors_1.default.white('\n      3. Type in the version that you like, and download the Xcode_x_x.xip file')}` +
                    `${ansi_colors_1.default.white('\n      4. Once the file is downloaded, click on .xip to extract it.')}` +
                    `${ansi_colors_1.default.white('\n      5. Now click on that Xcode file complete all the installation process')}` +
                    `${ansi_colors_1.default.white('\n      6. After completion drag the Xcode to Applications folder')}`, { padding: 1 }));
                logger_1.default.log(`\nFollow the guide for more detailed info ${ansi_colors_1.default.magenta('https://www.freecodecamp.org/news/how-to-download-and-install-xcode/')}\n`);
                result.simulator = false;
            }
        }
        if (setupConfigs.mode === 'real' || setupConfigs.mode === 'both') {
            logger_1.default.log('\nSetting up missing requirements for real devices...');
            let msg = ansi_colors_1.default.cyan('1. Remote Automation should be turned on your iOS device.') +
                ansi_colors_1.default.grey.italic('\n(turn it on via Settings → Safari → Advanced → Remote Automation.)');
            if (missingRequirements.includes('Device is not connected')) {
                msg += ansi_colors_1.default.cyan('\n\n2. Device is connected via data cable and turned on properly.');
                result.real = false;
            }
            logger_1.default.log((0, boxen_1.default)(msg, { padding: 1 }));
        }
        return result;
    }
    showHelp(unknownOptions) {
        if (unknownOptions.length) {
            logger_1.default.log(ansi_colors_1.default.red(`unknown option(s) passed: ${unknownOptions.join(', ')}\n`));
        }
        logger_1.default.log(`Usage: ${ansi_colors_1.default.cyan('npx @nightwatch/mobile-helper ios [options]')}`);
        logger_1.default.log('  Verify if all the requirements are met to run tests on an iOS device/simulator.\n');
        logger_1.default.log(`${ansi_colors_1.default.yellow('Options:')}`);
        const switches = Object.keys(constants_1.AVAILABLE_OPTIONS).reduce((acc, key) => {
            acc[key] = [key].concat(constants_1.AVAILABLE_OPTIONS[key].alias || [])
                .map(function (sw) {
                return (sw.length > 1 ? '--' : '-') + sw;
            })
                .join(', ');
            return acc;
        }, {});
        const longest = (xs) => Math.max.apply(null, xs.map(x => x.length));
        const switchlen = longest(Object.keys(switches).map(function (s) {
            return switches[s] || '';
        }));
        const desclen = longest(Object.keys(constants_1.AVAILABLE_OPTIONS).map((option) => {
            return constants_1.AVAILABLE_OPTIONS[option].description;
        }));
        Object.keys(constants_1.AVAILABLE_OPTIONS).forEach(key => {
            const kswitch = switches[key];
            let desc = constants_1.AVAILABLE_OPTIONS[key].description;
            const spadding = new Array(Math.max(switchlen - kswitch.length + 3, 0)).join('.');
            const dpadding = new Array(Math.max(desclen - desc.length + 1, 0)).join(' ');
            if (dpadding.length > 0) {
                desc += dpadding;
            }
            const prelude = '  ' + (kswitch) + ' ' + ansi_colors_1.default.grey(spadding);
            logger_1.default.log(prelude + ' ' + ansi_colors_1.default.grey(desc));
        });
    }
    getAllAvailableOptions = () => {
        const mainOptions = Object.keys(constants_1.AVAILABLE_OPTIONS);
        const allOptions = [];
        mainOptions.forEach((option) => allOptions.push(option, ...constants_1.AVAILABLE_OPTIONS[option].alias));
        return allOptions;
    };
}
exports.IosSetup = IosSetup;
