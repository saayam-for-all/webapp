"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.killEmulatorWithoutWait = exports.launchAVD = exports.getAlreadyRunningAvd = exports.waitForBootUp = void 0;
const ansi_colors_1 = __importDefault(require("ansi-colors"));
const child_process_1 = require("child_process");
const path_1 = __importDefault(require("path"));
const utils_1 = require("../../utils");
const appium_adb_1 = __importDefault(require("./utils/appium-adb"));
const common_1 = require("./utils/common");
const sdk_1 = require("./utils/sdk");
const waitForBootUp = (sdkRoot, platform, udid) => {
    console.log('Waiting for emulator to boot up...');
    const bootUpStdout = (0, sdk_1.execBinarySync)((0, common_1.getBinaryLocation)(sdkRoot, platform, 'adb', true), 'adb', platform, `-s ${udid} wait-for-local-device`);
    if (bootUpStdout !== null) {
        console.log(`  ${ansi_colors_1.default.green((0, utils_1.symbols)().ok)} Boot up complete!\n`);
        return true;
    }
    else {
        console.log('Failed to get the status of boot up!\n');
        return false;
    }
};
exports.waitForBootUp = waitForBootUp;
const getAlreadyRunningAvd = async (sdkRoot, platform, avdName) => {
    console.log('Checking if AVD is already running...');
    const appiumAdb = await appium_adb_1.default.createADB({ allowOfflineDevices: true });
    try {
        const avdAlreadyRunning = await appiumAdb.getRunningAVD(avdName);
        if (avdAlreadyRunning) {
            console.log(`  ${ansi_colors_1.default.green((0, utils_1.symbols)().ok)} '${avdName}' AVD already found running!\n`);
            if (avdAlreadyRunning.state !== 'device') {
                const bootUpComplete = (0, exports.waitForBootUp)(sdkRoot, platform, avdAlreadyRunning.udid);
                if (!bootUpComplete) {
                    return null;
                }
            }
            console.log('Ensuring AVD is ready to accept further commands...');
            try {
                await appiumAdb.waitForEmulatorReady(60000);
                console.log(`  ${ansi_colors_1.default.green((0, utils_1.symbols)().ok)} AVD is ready!\n`);
            }
            catch (err) {
                console.log(`  ${ansi_colors_1.default.red((0, utils_1.symbols)().fail)} ${err}\n`);
                return null;
            }
            return avdAlreadyRunning.udid;
        }
        else {
            console.log(`  ${ansi_colors_1.default.yellow('!')} '${avdName}' AVD not found running!\n`);
        }
    }
    catch {
        console.log(`  ${ansi_colors_1.default.red((0, utils_1.symbols)().fail)} Failed to find running AVDs.\n`);
    }
    return null;
};
exports.getAlreadyRunningAvd = getAlreadyRunningAvd;
const launchAVD = async (sdkRoot, platform, avdName) => {
    // Kill AVD if already present.
    const appiumAdb = await appium_adb_1.default.createADB({ allowOfflineDevices: true });
    try {
        const avdAlreadyRunning = await appiumAdb.getRunningAVD(avdName);
        if (avdAlreadyRunning) {
            console.log('Killing already running AVD...');
            try {
                await appiumAdb.killEmulator(avdName);
                console.log(`  ${ansi_colors_1.default.green((0, utils_1.symbols)().ok)} AVD killed successfully!\n`);
            }
            catch {
                console.log(`  ${ansi_colors_1.default.red((0, utils_1.symbols)().fail)} Failed to kill the already running AVD!`);
                console.log('Please close the AVD and re-run the command.\n');
                return null;
            }
        }
        // eslint-disable-next-line
    }
    catch { }
    console.log(`Launching emulator with '${avdName}' AVD...`);
    const emuLocation = (0, common_1.getBinaryLocation)(sdkRoot, platform, 'emulator', true);
    const emuFullName = path_1.default.basename(emuLocation);
    const emuDirPath = path_1.default.dirname(emuLocation);
    let cmd;
    if (platform === 'windows') {
        cmd = `${emuFullName} @${avdName} -delay-adb`;
    }
    else {
        cmd = `./${emuFullName} @${avdName} -delay-adb`;
    }
    (0, child_process_1.exec)(cmd, {
        cwd: emuDirPath
    });
    try {
        const avdRunning = await appiumAdb.getRunningAVDWithRetry(avdName);
        if (avdRunning) {
            console.log(`  ${ansi_colors_1.default.green((0, utils_1.symbols)().ok)} '${avdName}' AVD launched!\n`);
            const bootUpComplete = (0, exports.waitForBootUp)(sdkRoot, platform, avdRunning.udid);
            if (bootUpComplete) {
                return avdRunning.udid;
            }
            else {
                return null;
            }
        }
        else {
            console.log(`  ${ansi_colors_1.default.red((0, utils_1.symbols)().fail)} Failed to launch AVD! Exiting...\n`);
            return null;
        }
    }
    catch {
        console.log('Failed to get the status of AVD launch. Exiting...\n');
    }
    return null;
};
exports.launchAVD = launchAVD;
const killEmulatorWithoutWait = (sdkRoot, platform, emulatorId) => {
    const emulatorIdFlag = emulatorId ? `-s ${emulatorId} ` : '';
    (0, sdk_1.execBinarySync)((0, common_1.getBinaryLocation)(sdkRoot, platform, 'adb', true), 'adb', platform, `${emulatorIdFlag}emu kill`);
};
exports.killEmulatorWithoutWait = killEmulatorWithoutWait;
