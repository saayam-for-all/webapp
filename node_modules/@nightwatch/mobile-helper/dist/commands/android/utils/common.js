"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.checkJavaInstallation = exports.getSdkRootFromEnv = exports.downloadFirefoxAndroid = exports.getFirefoxApkName = exports.getLatestVersion = exports.downloadWithProgressBar = exports.getBinaryLocation = exports.getBinaryNameForOS = exports.getAllAvailableOptions = void 0;
const ansi_colors_1 = __importDefault(require("ansi-colors"));
const axios_1 = __importDefault(require("axios"));
const child_process_1 = require("child_process");
const cli_progress_1 = __importDefault(require("cli-progress"));
const fs_1 = __importDefault(require("fs"));
const os_1 = __importDefault(require("os"));
const path_1 = __importDefault(require("path"));
const untildify_1 = __importDefault(require("untildify"));
const which_1 = __importDefault(require("which"));
const logger_1 = __importDefault(require("../../../logger"));
const utils_1 = require("../../../utils");
const constants_1 = require("../constants");
const getAllAvailableOptions = () => {
    const mainOptions = Object.keys(constants_1.AVAILABLE_OPTIONS);
    const allOptions = [];
    mainOptions.forEach((option) => allOptions.push(option, ...constants_1.AVAILABLE_OPTIONS[option].alias));
    return allOptions;
};
exports.getAllAvailableOptions = getAllAvailableOptions;
const getBinaryNameForOS = (platform, binaryName) => {
    if (platform !== 'windows') {
        return binaryName;
    }
    if (['sdkmanager', 'avdmanager', 'apksigner'].includes(binaryName)) {
        return `${binaryName}.bat`;
    }
    if (!path_1.default.extname(binaryName)) {
        return `${binaryName}.exe`;
    }
    return binaryName;
};
exports.getBinaryNameForOS = getBinaryNameForOS;
const getBinaryLocation = (sdkRoot, platform, binaryName, suppressOutput = false) => {
    const failLocations = [];
    const binaryFullName = (0, exports.getBinaryNameForOS)(platform, binaryName);
    const pathToBinary = path_1.default.join(sdkRoot, constants_1.SDK_BINARY_LOCATIONS[binaryName], binaryFullName);
    if (fs_1.default.existsSync(pathToBinary)) {
        if (!suppressOutput) {
            console.log(`  ${ansi_colors_1.default.green((0, utils_1.symbols)().ok)} ${ansi_colors_1.default.cyan(binaryName)} binary is present at '${pathToBinary}'`);
        }
        return pathToBinary;
    }
    failLocations.push(pathToBinary);
    if (binaryName === 'adb') {
        // look for adb in sdkRoot (as it is a standalone binary).
        const adbPath = path_1.default.join(sdkRoot, binaryFullName);
        if (fs_1.default.existsSync(adbPath)) {
            if (!suppressOutput) {
                console.log(`  ${ansi_colors_1.default.green((0, utils_1.symbols)().ok)} ${ansi_colors_1.default.cyan(binaryName)} binary is present at '${adbPath}'`);
            }
            return adbPath;
        }
        failLocations.push(adbPath);
        // Look for adb in PATH also (runnable as `adb --version`)
        const adbLocation = which_1.default.sync(binaryFullName, { nothrow: true });
        if (adbLocation) {
            if (!suppressOutput) {
                console.log(`  ${ansi_colors_1.default.green((0, utils_1.symbols)().ok)} ${ansi_colors_1.default.cyan(binaryName)} binary is present at '${adbPath}' which is added in 'PATH'`);
            }
            return 'PATH';
        }
        failLocations.push('PATH');
    }
    if (!suppressOutput) {
        for (const location of failLocations) {
            console.log(`  ${ansi_colors_1.default.red((0, utils_1.symbols)().fail)} ${ansi_colors_1.default.cyan(binaryName)} binary not present at '${location}'`);
        }
    }
    return '';
};
exports.getBinaryLocation = getBinaryLocation;
const downloadWithProgressBar = async (url, dest, extract = false) => {
    const { default: download } = await import('download');
    const progressBar = new cli_progress_1.default.Bar({
        format: ' [{bar}] {percentage}% | ETA: {eta}s'
    }, cli_progress_1.default.Presets.shades_classic);
    try {
        const stream = download(url, dest, {
            extract
        });
        progressBar.start(100, 0);
        await stream.on('downloadProgress', function (progress) {
            progressBar.update(progress.percent * 100);
        });
        progressBar.stop();
        return true;
    }
    catch {
        progressBar.stop();
        return false;
    }
};
exports.downloadWithProgressBar = downloadWithProgressBar;
const getLatestVersion = async (browser) => {
    if (browser === 'firefox') {
        try {
            const { data } = await (0, axios_1.default)('https://api.github.com/repos/mozilla-mobile/fenix/releases/latest');
            return data['tag_name'].slice(1);
        }
        catch {
            return constants_1.DEFAULT_FIREFOX_VERSION;
        }
    }
    else {
        return constants_1.DEFAULT_CHROME_VERSIONS[1];
    }
};
exports.getLatestVersion = getLatestVersion;
const getFirefoxApkName = (version) => {
    return `fenix-${version}.multi.android-${constants_1.ABI}.apk`;
};
exports.getFirefoxApkName = getFirefoxApkName;
const downloadFirefoxAndroid = async (version) => {
    if (!version) {
        version = await (0, exports.getLatestVersion)('firefox');
    }
    const tempdir = os_1.default.tmpdir();
    const apkName = (0, exports.getFirefoxApkName)(version);
    if (fs_1.default.existsSync(path_1.default.join(tempdir, apkName))) {
        console.log(`  ${ansi_colors_1.default.green((0, utils_1.symbols)().ok)} APK already downloaded.`);
        return true;
    }
    const apkDownloadUrl = `https://archive.mozilla.org/pub/fenix/releases/${version}/android/fenix-${version}-android-${constants_1.ABI}/${apkName}`;
    return await (0, exports.downloadWithProgressBar)(apkDownloadUrl, tempdir);
};
exports.downloadFirefoxAndroid = downloadFirefoxAndroid;
const getSdkRootFromEnv = (cwd, androidHomeInGlobalEnv) => {
    logger_1.default.log('Checking the value of ANDROID_HOME environment variable...');
    const androidHome = process.env.ANDROID_HOME;
    const fromDotEnv = androidHomeInGlobalEnv ? '' : ' (taken from .env)';
    if (androidHome) {
        const androidHomeFinal = (0, untildify_1.default)(androidHome);
        const androidHomeAbsolute = path_1.default.resolve(cwd, androidHomeFinal);
        if (androidHomeFinal !== androidHomeAbsolute) {
            logger_1.default.log(`  ${ansi_colors_1.default.yellow('!')} ANDROID_HOME is set to '${androidHomeFinal}'${fromDotEnv} which is NOT an absolute path.`);
            logger_1.default.log(`  ${ansi_colors_1.default.green((0, utils_1.symbols)().ok)} Considering ANDROID_HOME to be '${androidHomeAbsolute}'\n`);
            return androidHomeAbsolute;
        }
        logger_1.default.log(`  ${ansi_colors_1.default.green((0, utils_1.symbols)().ok)} ANDROID_HOME is set to '${androidHomeFinal}'${fromDotEnv}\n`);
        return androidHomeFinal;
    }
    if (androidHome === undefined) {
        logger_1.default.log(`  ${ansi_colors_1.default.red((0, utils_1.symbols)().fail)} ANDROID_HOME environment variable is NOT set!\n`);
    }
    else {
        logger_1.default.log(`  ${ansi_colors_1.default.red((0, utils_1.symbols)().fail)} ANDROID_HOME is set to '${androidHome}'${fromDotEnv} which is NOT a valid path!\n`);
    }
    return '';
};
exports.getSdkRootFromEnv = getSdkRootFromEnv;
const checkJavaInstallation = (cwd) => {
    try {
        (0, child_process_1.execSync)('java -version', {
            stdio: 'pipe',
            cwd: cwd
        });
        return true;
    }
    catch {
        logger_1.default.log(`${ansi_colors_1.default.red('Error:')} Java Development Kit v9 or above is required to work with Android SDKs. Download from here:`);
        logger_1.default.log(ansi_colors_1.default.cyan('  https://www.oracle.com/java/technologies/downloads/'), '\n');
        logger_1.default.log(`Make sure Java is installed by running ${ansi_colors_1.default.green('java -version')} command and then re-run this tool.\n`);
        return false;
    }
};
exports.checkJavaInstallation = checkJavaInstallation;
