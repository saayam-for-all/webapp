"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.verifyOptions = exports.showMissingBinaryHelp = exports.getInstalledSystemImages = exports.showConnectedEmulators = exports.showConnectedRealDevices = void 0;
const ansi_colors_1 = __importDefault(require("ansi-colors"));
const logger_1 = __importDefault(require("../../../logger"));
const utils_1 = require("../../../utils");
const constants_1 = require("../constants");
const appium_adb_1 = __importDefault(require("../utils/appium-adb"));
const sdk_1 = require("../utils/sdk");
const help_1 = require("./help");
const deviceStateWithColor = (state) => {
    switch (state) {
        case 'device':
            return ansi_colors_1.default.green(state) + ansi_colors_1.default.gray(' (online)');
        case 'offline':
            return ansi_colors_1.default.red(state);
        default:
            return ansi_colors_1.default.gray(state);
    }
};
async function showConnectedRealDevices() {
    try {
        const adb = await appium_adb_1.default.createADB({ allowOfflineDevices: true });
        const connectedDevices = await adb.getConnectedDevices();
        const connectedRealDevices = connectedDevices.filter((device) => {
            return !device.udid.includes('emulator') && !device.udid.includes('_adb-tls-connect');
        });
        if (connectedRealDevices.length === 0) {
            return true;
        }
        logger_1.default.log(ansi_colors_1.default.bold('Connected Real Devices:'));
        connectedRealDevices.forEach((device, index) => {
            logger_1.default.log(`  ${index + 1}. udid/deviceId: ${ansi_colors_1.default.green(device.udid)} / state: ${deviceStateWithColor(device.state)}`);
        });
        logger_1.default.log();
        return true;
    }
    catch (error) {
        logger_1.default.log(ansi_colors_1.default.red('Error occurred while showing connected real devices.'));
        console.error(error);
        return false;
    }
}
exports.showConnectedRealDevices = showConnectedRealDevices;
async function showConnectedEmulators() {
    try {
        const adb = await appium_adb_1.default.createADB({ allowOfflineDevices: true });
        const connectedEmulators = await adb.getConnectedEmulators();
        if (connectedEmulators.length === 0) {
            return true;
        }
        logger_1.default.log(ansi_colors_1.default.bold('Connected Emulators:'));
        connectedEmulators.forEach((emu, index) => {
            logger_1.default.log(`  ${index + 1}. udid/deviceId: ${ansi_colors_1.default.green(emu.udid)} / state: ${deviceStateWithColor(emu.state)}`);
        });
        logger_1.default.log();
        return true;
    }
    catch (error) {
        logger_1.default.log(ansi_colors_1.default.red('Error occurred while showing connected emulators.'));
        console.error(error);
        return false;
    }
}
exports.showConnectedEmulators = showConnectedEmulators;
async function getInstalledSystemImages(sdkmanagerLocation, platform) {
    const stdout = (0, sdk_1.execBinarySync)(sdkmanagerLocation, 'sdkmanager', platform, '--list');
    if (!stdout) {
        logger_1.default.log(`\n${ansi_colors_1.default.red('Failed to fetch system images!')} Please try again.`);
        return false;
    }
    const lines = stdout.split('\n');
    const installedImages = [];
    for (const line of lines) {
        if (line.includes('Available Packages:')) {
            break;
        }
        if (line.includes('system-images')) {
            installedImages.push(line.split('|')[0].trim());
        }
    }
    return installedImages;
}
exports.getInstalledSystemImages = getInstalledSystemImages;
function showMissingBinaryHelp(binaryName) {
    logger_1.default.log(`  ${ansi_colors_1.default.red((0, utils_1.symbols)().fail)} ${ansi_colors_1.default.cyan(binaryName)} binary not found.\n`);
    logger_1.default.log(`Run: ${ansi_colors_1.default.cyan('npx @nightwatch/mobile-helper android --standalone')} to setup missing requirements.`);
    logger_1.default.log(`(Remove the ${ansi_colors_1.default.gray('--standalone')} flag from the above command if setting up for testing.)\n`);
}
exports.showMissingBinaryHelp = showMissingBinaryHelp;
function verifyOptions(subcommand, options) {
    const optionsPassed = Object.keys(options).filter(option => options[option] !== false);
    const allowedFlags = constants_1.AVAILABLE_SUBCOMMANDS[subcommand].flags;
    const allowedFlagNames = allowedFlags.map(flag => flag.name);
    // Divide the optionsPassed array in two arrays: flagsPassed and configsPassed.
    // flagsPassed contains the flags that are available for the subcommand.
    // configsPassed contains the config options with string or boolean values corresponding to the flag.
    const flagsPassed = optionsPassed.filter(option => allowedFlagNames.includes(option));
    const configsPassed = optionsPassed.filter(option => !allowedFlagNames.includes(option));
    // CHECK THE VALIDITY OF FLAG(s) PASSED
    if (flagsPassed.length > 1) {
        // A subcommand can only take one flag at a time.
        logger_1.default.log(`${ansi_colors_1.default.red(`Too many flags passed for '${subcommand}' subcommand:`)} ${flagsPassed.join(', ')} ${ansi_colors_1.default.gray('(only one expected)')}`);
        (0, help_1.showHelp)(subcommand);
        return false;
    }
    if (allowedFlags.length && flagsPassed.length === 0) {
        // If the subcommand expects a flag but it is not passed:
        // - if instead some other options are passed, throw error (we don't know if the options passed are configs and for which flag).
        // - if no other options are passed, then we can prompt them for the flag and related configs.
        if (configsPassed.length > 0) {
            logger_1.default.log(`${ansi_colors_1.default.red(`Unknown flag(s) passed for '${subcommand}' subcommand:`)} ${configsPassed.join(', ')}`);
            (0, help_1.showHelp)(subcommand);
            return false;
        }
        return {
            subcommandFlag: '',
            configs: []
        };
    }
    // CHECK THE VALIDITY OF CONFIGS PASSED
    const subcommandFlag = flagsPassed[0] || ''; // '' if no flag is allowed for the subcommand.
    if (configsPassed.length === 0) {
        // If no configs are passed, then we simply return and continue with the default subcommand flow.
        return {
            subcommandFlag,
            configs: []
        };
    }
    let allowedConfigs = [];
    let configsFor = '';
    if (!allowedFlags.length) {
        allowedConfigs = constants_1.AVAILABLE_SUBCOMMANDS[subcommand].cliConfigs || [];
        configsFor = ` for '${subcommand}' subcommand`;
    }
    else {
        allowedConfigs = allowedFlags.find(flag => flag.name === subcommandFlag)?.cliConfigs || [];
        configsFor = ` for '--${subcommandFlag}' flag`;
    }
    if (allowedConfigs.length) {
        // Check if the passed configs are valid.
        const configNames = allowedConfigs.map(config => config.name);
        const configAliases = [];
        allowedConfigs.forEach(config => configAliases.push(...config.alias));
        configNames.push(...configAliases);
        const unknownConfigs = configsPassed.filter(option => !configNames.includes(option));
        if (unknownConfigs.length) {
            logger_1.default.log(`${ansi_colors_1.default.red(`Unknown config(s) passed${configsFor}:`)} ${unknownConfigs.join(', ')}`);
            (0, help_1.showHelp)(subcommand);
            return false;
        }
        // set main config in `options` if config aliases are passed.
        const aliasToMainConfig = {};
        allowedConfigs.forEach(config => {
            config.alias.forEach(alias => {
                aliasToMainConfig[alias] = config.name;
            });
        });
        configsPassed.forEach((configName) => {
            if (aliasToMainConfig[configName]) {
                // `configName` is an alias
                const mainConfig = aliasToMainConfig[configName];
                options[mainConfig] = options[configName];
            }
        });
    }
    else {
        // if no configs are allowed for the flag but still some options are passed, then throw error.
        logger_1.default.log(`${ansi_colors_1.default.red(`Unknown config(s) passed${configsFor}:`)} ${configsPassed.join(', ')} ${ansi_colors_1.default.gray('(none expected)')}`);
        (0, help_1.showHelp)(subcommand);
        return false;
    }
    return {
        subcommandFlag,
        configs: configsPassed
    };
}
exports.verifyOptions = verifyOptions;
