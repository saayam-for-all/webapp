"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getSubcommandFlagsHelp = exports.getSubcommandHelp = exports.showHelp = void 0;
const ansi_colors_1 = __importDefault(require("ansi-colors"));
const logger_1 = __importDefault(require("../../../logger"));
const constants_1 = require("../constants");
function showHelp(subcommand) {
    const subcmd = constants_1.AVAILABLE_SUBCOMMANDS[subcommand];
    const subcmdFlagUsage = subcmd.flags.length ? ' [flag]' : '';
    logger_1.default.log(`Usage: ${ansi_colors_1.default.cyan(`npx @nightwatch/mobile-helper android ${subcommand}${subcmdFlagUsage} [configs]`)}\n`);
    const subcmdFlagsHelp = (0, exports.getSubcommandFlagsHelp)(subcmd);
    if (subcmdFlagsHelp) {
        logger_1.default.log(ansi_colors_1.default.yellow('Available flags:'));
        logger_1.default.log(subcmdFlagsHelp);
    }
}
exports.showHelp = showHelp;
const getSubcommandHelp = () => {
    let output = '';
    output += `Usage: ${ansi_colors_1.default.cyan('npx @nightwatch/mobile-helper android SUBCOMMAND [flag] [configs]')}\n`;
    output += '  Perform common Android SDK operations using subcommands.\n\n';
    output += `${ansi_colors_1.default.yellow('Subcommands (with available flags and configs):')}\n`;
    // A subcommand can allow multiple flags to facilitate different workflows, and each flag can
    // allow multiple configs to customize the workflow.
    // But, if a subcommand has a single workflow, then it doesn't require any flag and can have
    // multiple configs directly associated with the subcommand itself.
    Object.keys(constants_1.AVAILABLE_SUBCOMMANDS).forEach(subcommand => {
        const subcmd = constants_1.AVAILABLE_SUBCOMMANDS[subcommand];
        const subcmdFlagsUsage = subcmd.flags?.map(flag => `[--${flag.name}]`).join(' ') || '';
        const subcmdConfigsUsage = generateConfigsUsageString(subcmd.cliConfigs || []);
        // Display the subcommand name along with flags in the format:
        // 'subcommand [--flag1] [--flag2]'
        // OR
        // Display the subcommand name along with direct configs in the format:
        // 'subcommand [--config1 <usageHelp>] [--config2 <usageHelp>]'
        output += `  ${ansi_colors_1.default.cyan(subcommand)} ${subcmdFlagsUsage}${subcmdConfigsUsage}\n`;
        output += `  ${ansi_colors_1.default.gray(subcmd.description)}\n`;
        // Append a list of configs allowed for the subcommand, along with their aliases and description.
        if (subcmd.cliConfigs) {
            const configsWithAlias = getConfigsWithAlias(subcmd.cliConfigs);
            subcmd.cliConfigs.forEach((config, idx) => {
                const padding = generatePadding(configsWithAlias, configsWithAlias[idx].length);
                output += `    ${configsWithAlias[idx]} ${ansi_colors_1.default.grey(padding)} ${ansi_colors_1.default.gray(config.description)}\n`;
            });
        }
        output += (0, exports.getSubcommandFlagsHelp)(subcmd);
        output += '\n';
    });
    return output;
};
exports.getSubcommandHelp = getSubcommandHelp;
/**
 * Display a list of flags followed by their allowed configs for a subcommand.
 */
const getSubcommandFlagsHelp = (subcmd) => {
    let output = '';
    if (subcmd.flags.length) {
        // Generate a list of flags usage with configs in the format:
        // '--flag1 [--config11 <usageHelp>] [--config12 <usageHelp>]',
        // '--flag2 [--config21 <usageHelp>] [--config22 <usageHelp>]'
        const flagsUsageWithConfigs = subcmd.flags.map((flag) => {
            let flagHelp = `--${flag.name}`;
            if (flag.cliConfigs) {
                flagHelp += ' ' + generateConfigsUsageString(flag.cliConfigs);
            }
            return flagHelp;
        });
        // Generate final help output for each flag.
        subcmd.flags.forEach((flag, idx) => {
            const padding = generatePadding(flagsUsageWithConfigs, flagsUsageWithConfigs[idx].length);
            output += `    ${flagsUsageWithConfigs[idx]} ${ansi_colors_1.default.grey(padding)} ${ansi_colors_1.default.gray(flag.description)}\n`;
            // Append a list of configs allowed for the flag, along with their aliases and description.
            if (flag.cliConfigs) {
                const configsWithAlias = getConfigsWithAlias(flag.cliConfigs);
                flag.cliConfigs.forEach((config, idx) => {
                    const padding = generatePadding(configsWithAlias, configsWithAlias[idx].length);
                    output += `        ${configsWithAlias[idx]} ${ansi_colors_1.default.grey(padding)} ${ansi_colors_1.default.gray(config.description)}\n`;
                });
            }
        });
    }
    return output;
};
exports.getSubcommandFlagsHelp = getSubcommandFlagsHelp;
/*
 * Generate a string of configs in the format:
 * [--config1 <usageHelp>] [--config2 <usageHelp>] ...
 */
const generateConfigsUsageString = (configs) => {
    let configsStr = '';
    configs.forEach(config => {
        configsStr += `[--${config.name} <${config.usageHelp}>]`;
    });
    return configsStr;
};
/**
* Generate a list of configs with their aliases in the format:
* '--config1 | -c11 | -c12',
* '--config2 | -c21 | -c22'
*/
const getConfigsWithAlias = (configs) => {
    const configsWithAlias = configs.map(config => {
        const configAlias = config.alias.map(alias => `-${alias}`).join(' | ');
        return `--${config.name}` + (configAlias ? ` | ${configAlias}` : '');
    });
    return configsWithAlias;
};
const generatePadding = (array, length) => {
    const longest = (xs) => Math.max.apply(null, xs.map(x => x.length));
    const padding = new Array(Math.max(longest(array) - length + 3, 0)).join('.');
    return padding;
};
