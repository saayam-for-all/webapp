"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AndroidSetup = void 0;
const ansi_colors_1 = __importDefault(require("ansi-colors"));
const boxen_1 = __importDefault(require("boxen"));
const child_process_1 = require("child_process");
const dotenv = __importStar(require("dotenv"));
const fs_1 = __importDefault(require("fs"));
const os_1 = __importDefault(require("os"));
const path_1 = __importDefault(require("path"));
const untildify_1 = __importDefault(require("untildify"));
const inquirer_1 = require("inquirer");
const logger_1 = __importDefault(require("../../logger"));
const utils_1 = require("../../utils");
const adb_1 = require("./adb");
const constants_1 = require("./constants");
const downloads_json_1 = __importDefault(require("./downloads.json"));
const help_1 = require("./subcommands/help");
const common_1 = require("./utils/common");
const sdk_1 = require("./utils/sdk");
class AndroidSetup {
    sdkRoot;
    javaHome;
    options;
    rootDir;
    platform;
    otherInfo;
    constructor(options = {}, rootDir = process.cwd()) {
        this.sdkRoot = '';
        this.javaHome = '';
        this.options = options;
        this.rootDir = rootDir;
        this.platform = (0, utils_1.getPlatformName)();
        this.otherInfo = {
            androidHomeInGlobalEnv: false,
            javaHomeInGlobalEnv: false
        };
    }
    async run() {
        const allAvailableOptions = (0, common_1.getAllAvailableOptions)();
        const unknownOptions = Object.keys(this.options).filter((option) => !allAvailableOptions.includes(option));
        if (this.options.help || unknownOptions.length) {
            this.showOptionsHelp(unknownOptions);
            if (this.options.help) {
                logger_1.default.log('\n' + (0, help_1.getSubcommandHelp)());
            }
            return this.options.help === true;
        }
        const javaInstalled = (0, common_1.checkJavaInstallation)(this.rootDir);
        if (!javaInstalled) {
            return false;
        }
        this.loadEnvFromDotEnv();
        let javaHomeFound = false;
        if (this.options.appium) {
            javaHomeFound = this.isJavaHomeEnvSet();
            if (!javaHomeFound) {
                this.javaHomeNotFoundInstructions();
                if (javaHomeFound === false) {
                    logger_1.default.log(`${ansi_colors_1.default.red('ERROR:')} JAVA_HOME env variable could not be set in a .env file. Please set the JAVA_HOME env variable as instructed above.`);
                    this.envSetHelp();
                    return false;
                }
                // env can be set in dotenv file (javaHomeFound=null).
                process.env.JAVA_HOME = await this.getJavaHomeFromUser();
            }
            this.javaHome = process.env.JAVA_HOME || '';
        }
        const sdkRootEnv = (0, common_1.getSdkRootFromEnv)(this.rootDir, this.otherInfo.androidHomeInGlobalEnv);
        if (this.options.appium && !sdkRootEnv && this.otherInfo.androidHomeInGlobalEnv) {
            // ANDROID_HOME is set to an invalid path in system env. We can get around this for mobile-web
            // since ANDROID_HOME is not a mandatory requirement there and Nightwatch would complain when it
            // is required, but for Appium to work properly, it should be set to correct path in sys env or .env.
            logger_1.default.log(`${ansi_colors_1.default.red('ERROR:')} For Appium to work properly, ${ansi_colors_1.default.cyan('ANDROID_HOME')} env variable must be set to a valid path in your system environment variables.`);
            this.envSetHelp();
            return false;
        }
        this.sdkRoot = sdkRootEnv || await this.getSdkRootFromUser();
        process.env.ANDROID_HOME = this.sdkRoot;
        let result = true;
        const setupConfigs = await this.getSetupConfigs(this.options);
        logger_1.default.log();
        const missingRequirements = this.verifySetup(setupConfigs);
        if (missingRequirements.length) {
            if (!this.options.setup) {
                logger_1.default.log(`Some requirements are missing: ${ansi_colors_1.default.red(missingRequirements.join(', '))}\n`);
                this.options.setup = await this.askToSetupAndroid('Do you wish to download the missing binaries and complete setup?');
            }
            if (this.options.setup) {
                result = await this.setupAndroid(setupConfigs, missingRequirements);
            }
            else {
                result = false;
            }
        }
        if (setupConfigs.mode !== 'real' && result) {
            // Only verify/install browsers if working with emulator and
            // all processes before have passed.
            result = await this.verifyAndSetupBrowsers(setupConfigs.browsers);
        }
        this.postSetupInstructions(result, setupConfigs);
        if (!this.options.standalone && setupConfigs.mode !== 'emulator') {
            logger_1.default.log(`${ansi_colors_1.default.bold('Note:')} Please make sure you have required browsers installed on your real-device before running tests.\n`);
        }
        if (!sdkRootEnv || (this.options.appium && !javaHomeFound)) {
            this.envSetInstructions(sdkRootEnv);
        }
        return {
            status: result,
            setup: !!this.options.setup,
            mode: setupConfigs.mode || 'real'
        };
    }
    showOptionsHelp(unknownOptions) {
        if (unknownOptions.length) {
            logger_1.default.log(ansi_colors_1.default.red(`unknown option(s) passed: ${unknownOptions.join(', ')}\n`));
        }
        logger_1.default.log(`Usage: ${ansi_colors_1.default.cyan('npx @nightwatch/mobile-helper android [options]')}`);
        logger_1.default.log('  Verify if all the requirements are met to run tests on an Android device/emulator.\n');
        logger_1.default.log(`${ansi_colors_1.default.yellow('Options:')}`);
        const switches = Object.keys(constants_1.AVAILABLE_OPTIONS).reduce((acc, key) => {
            acc[key] = [key].concat(constants_1.AVAILABLE_OPTIONS[key].alias || [])
                .map(function (sw) {
                return (sw.length > 1 ? '--' : '-') + sw;
            })
                .join(', ');
            return acc;
        }, {});
        const longest = (xs) => Math.max.apply(null, xs.map(x => x.length));
        const switchlen = longest(Object.keys(switches).map(function (s) {
            return switches[s] || '';
        }));
        const desclen = longest(Object.keys(constants_1.AVAILABLE_OPTIONS).map((option) => {
            return constants_1.AVAILABLE_OPTIONS[option].description;
        }));
        Object.keys(constants_1.AVAILABLE_OPTIONS).forEach(key => {
            const kswitch = switches[key];
            let desc = constants_1.AVAILABLE_OPTIONS[key].description;
            const spadding = new Array(Math.max(switchlen - kswitch.length + 3, 0)).join('.');
            const dpadding = new Array(Math.max(desclen - desc.length + 1, 0)).join(' ');
            if (dpadding.length > 0) {
                desc += dpadding;
            }
            const prelude = '  ' + (kswitch) + ' ' + ansi_colors_1.default.grey(spadding);
            logger_1.default.log(prelude + ' ' + ansi_colors_1.default.grey(desc));
        });
    }
    loadEnvFromDotEnv() {
        this.otherInfo.androidHomeInGlobalEnv = 'ANDROID_HOME' in process.env;
        if (this.options.appium) {
            this.otherInfo.javaHomeInGlobalEnv = 'JAVA_HOME' in process.env;
        }
        dotenv.config({ path: path_1.default.join(this.rootDir, '.env') });
    }
    isJavaHomeEnvSet() {
        logger_1.default.log('Checking the value of JAVA_HOME environment variable...');
        const javaHome = process.env.JAVA_HOME;
        const fromDotEnv = this.otherInfo.javaHomeInGlobalEnv ? '' : ' (taken from .env)';
        if (javaHome !== undefined && fs_1.default.existsSync(javaHome)) {
            logger_1.default.log(`  ${ansi_colors_1.default.green((0, utils_1.symbols)().ok)} JAVA_HOME is set to '${javaHome}'${fromDotEnv}`);
            const javaHomeBin = path_1.default.resolve(javaHome, 'bin');
            if (fs_1.default.existsSync(javaHomeBin)) {
                logger_1.default.log(`  ${ansi_colors_1.default.green((0, utils_1.symbols)().ok)} 'bin' subfolder exists under '${javaHome}'\n`);
                return true;
            }
            logger_1.default.log(`  ${ansi_colors_1.default.red((0, utils_1.symbols)().fail)} 'bin' subfolder does not exist under '${javaHome}'. Is ${javaHome} set to a proper value?\n`);
            if (this.otherInfo.javaHomeInGlobalEnv) {
                // we cannot set it ourselves
                return false;
            }
            // We can set the env in dotenv file.
            return null;
        }
        if (javaHome === undefined) {
            logger_1.default.log(`  ${ansi_colors_1.default.red((0, utils_1.symbols)().fail)} JAVA_HOME env variable is NOT set!\n`);
        }
        else {
            logger_1.default.log(`  ${ansi_colors_1.default.red((0, utils_1.symbols)().fail)} JAVA_HOME is set to '${javaHome}'${fromDotEnv} but this is NOT a valid path!\n`);
            if (this.otherInfo.javaHomeInGlobalEnv) {
                // we cannot set it ourselves
                return false;
            }
        }
        // we can set the env in dotenv file.
        return null;
    }
    javaHomeNotFoundInstructions() {
        logger_1.default.log(`${ansi_colors_1.default.red('NOTE:')} For Appium to work properly, ${ansi_colors_1.default.cyan('JAVA_HOME')} env variable must be set to the root folder path of your local JDK installation.`);
        let expectedPath;
        if (this.platform === 'windows') {
            expectedPath = 'C:\\Program Files\\Java\\jdk1.8.0_111';
        }
        else if (this.platform === 'mac') {
            expectedPath = '/Library/Java/JavaVirtualMachines/jdk1.8.0_111.jdk/Contents/Home';
        }
        else {
            expectedPath = '/usr/lib/jvm/java-8-oracle';
        }
        logger_1.default.log(`${ansi_colors_1.default.green('Hint:')} On a ${this.platform} system, the JDK installation path should be something similar to '${expectedPath}'.\n`);
    }
    async getJavaHomeFromUser() {
        let javaHome;
        if (this.platform === 'mac') {
            try {
                const stdout = (0, child_process_1.execSync)('/usr/libexec/java_home', {
                    stdio: 'pipe'
                });
                javaHome = stdout.toString().trimEnd();
                logger_1.default.log(`${ansi_colors_1.default.green((0, utils_1.symbols)().ok)} Auto-detected JAVA_HOME to be: ${ansi_colors_1.default.green(javaHome)}`);
                // eslint-disable-next-line
            }
            catch { }
        }
        const answers = await (0, inquirer_1.prompt)([
            {
                type: 'input',
                name: 'javaHome',
                message: 'Enter the path to the root folder of your local JDK installation:',
                validate: (input) => {
                    if (!fs_1.default.existsSync(input)) {
                        return 'Entered path does not exist';
                    }
                    if (!fs_1.default.existsSync(path_1.default.resolve(input, 'bin'))) {
                        return `'bin' subfolder does not exist under '${input}'`;
                    }
                    return true;
                }
            }
        ], { javaHome });
        logger_1.default.log();
        const envPath = path_1.default.join(this.rootDir, '.env');
        fs_1.default.appendFileSync(envPath, `\nJAVA_HOME=${answers.javaHome}`);
        return answers.javaHome;
    }
    async getSdkRootFromUser() {
        const answers = await (0, inquirer_1.prompt)([
            {
                type: 'input',
                name: 'sdkRoot',
                message: 'Where do you want the Android SDK setup? Please give the path to your existing setup (if any):',
                default: (0, sdk_1.getDefaultAndroidSdkRoot)(this.platform),
                filter: (input) => path_1.default.resolve(this.rootDir, (0, untildify_1.default)(input))
            }
        ]);
        const { sdkRoot } = answers;
        if (!this.otherInfo.androidHomeInGlobalEnv) {
            // if ANDROID_HOME is already set in global env, saving it to .env is of no use.
            // this is important if global ANDROID_HOME env is set to '', in which case we
            // should not save the user supplied value to .env.
            const envPath = path_1.default.join(this.rootDir, '.env');
            fs_1.default.appendFileSync(envPath, `\nANDROID_HOME=${sdkRoot}`);
        }
        return sdkRoot;
    }
    getConfigFromOptions(options) {
        const configs = {};
        if (options.mode && typeof options.mode !== 'boolean') {
            const realMode = options.mode.includes('real');
            const emulatorMode = options.mode.includes('emulator');
            if ((realMode && emulatorMode) || options.mode.includes('both')) {
                configs.mode = 'both';
            }
            else if (realMode) {
                configs.mode = 'real';
            }
            else if (emulatorMode) {
                configs.mode = 'emulator';
            }
        }
        if (options.browsers && typeof options.browsers !== 'boolean') {
            const chrome = options.browsers.includes('chrome');
            const firefox = options.browsers.includes('firefox');
            if (options.browsers.includes('none')) {
                configs.browsers = 'none';
            }
            else if ((chrome && firefox) || options.browsers.includes('both')) {
                configs.browsers = 'both';
            }
            else if (chrome) {
                configs.browsers = 'chrome';
            }
            else if (firefox) {
                configs.browsers = 'firefox';
            }
        }
        // For standalone mode, don't ask the browser question (set `configs.browsers` to 'none').
        // But if a user explicitly provides a browser using the `--browsers` flag, use it.
        if (options.standalone && !configs.browsers) {
            configs.browsers = 'none';
            // if just the `--browsers` flag is passed with no argument,
            // ask the browser question even in the case of standalone.
            if (options.browsers === true) {
                delete configs.browsers;
            }
        }
        return configs;
    }
    async getSetupConfigs(options) {
        const configs = this.getConfigFromOptions(options);
        return await (0, inquirer_1.prompt)(constants_1.SETUP_CONFIG_QUES, configs);
    }
    async askToSetupAndroid(message) {
        const answers = await (0, inquirer_1.prompt)([
            {
                type: 'list',
                name: 'setupAndroid',
                message: message,
                choices: [{ name: 'Yes', value: true }, { name: 'Not now', value: false }],
                default: true
            }
        ]);
        logger_1.default.log();
        return answers.setupAndroid;
    }
    checkBinariesPresent(binaries) {
        const missingBinaries = [];
        for (const binaryName of binaries) {
            const binaryPath = (0, common_1.getBinaryLocation)(this.sdkRoot, this.platform, binaryName);
            if (!binaryPath) {
                missingBinaries.push(binaryName);
            }
        }
        logger_1.default.log();
        return missingBinaries;
    }
    checkBinariesWorking(binaries) {
        const nonWorkingBinaries = [];
        for (const binaryName of binaries) {
            const binaryPath = (0, common_1.getBinaryLocation)(this.sdkRoot, this.platform, binaryName, true);
            let cmd = '--version';
            if (binaryName === 'emulator') {
                cmd = '-version';
            }
            else if (binaryName === 'avdmanager') {
                cmd = 'list avd';
            }
            if (binaryPath) {
                const binaryWorking = (0, sdk_1.execBinarySync)(binaryPath, binaryName, this.platform, cmd);
                if (binaryWorking === null) {
                    nonWorkingBinaries.push(binaryName);
                }
            }
            else {
                logger_1.default.log(`  ${ansi_colors_1.default.red((0, utils_1.symbols)().fail)} ${ansi_colors_1.default.cyan(binaryName)} binary not found.`);
                nonWorkingBinaries.push(binaryName);
            }
        }
        if (nonWorkingBinaries.length) {
            logger_1.default.log();
        }
        return nonWorkingBinaries;
    }
    verifyAvdPresent() {
        const avdLocation = (0, common_1.getBinaryLocation)(this.sdkRoot, this.platform, 'avdmanager', true);
        if (!avdLocation) {
            return false;
        }
        let stdout = (0, sdk_1.execBinarySync)(avdLocation, 'avdmanager', this.platform, 'list avd');
        if (stdout !== null) {
            const nonWorkingAvdsIndex = stdout.indexOf('could not be loaded');
            if (nonWorkingAvdsIndex > -1) {
                stdout = stdout.slice(0, nonWorkingAvdsIndex);
            }
            if (stdout.includes(constants_1.NIGHTWATCH_AVD)) {
                return true;
            }
        }
        return false;
    }
    verifyAdbRunning() {
        logger_1.default.log('Making sure adb is running...');
        const adbLocation = (0, common_1.getBinaryLocation)(this.sdkRoot, this.platform, 'adb', true);
        if (!adbLocation) {
            logger_1.default.log(`  ${ansi_colors_1.default.red((0, utils_1.symbols)().fail)} ${ansi_colors_1.default.cyan('adb')} binary not found.\n`);
            return;
        }
        const serverStarted = (0, sdk_1.execBinarySync)(adbLocation, 'adb', this.platform, 'start-server');
        if (serverStarted !== null) {
            logger_1.default.log(`${ansi_colors_1.default.green('Success!')} adb server is running.\n`);
        }
        else {
            logger_1.default.log('Please try running the above command by yourself.\n');
        }
    }
    verifySetup(setupConfigs) {
        const missingRequirements = [];
        if (setupConfigs.mode === 'real') {
            logger_1.default.log('Verifying the setup requirements for real devices...');
        }
        else if (setupConfigs.mode === 'emulator') {
            logger_1.default.log('Verifying the setup requirements for Android emulator...');
        }
        else {
            logger_1.default.log('Verifying the setup requirements for real devices/emulator...');
        }
        const requiredBinaries = ['adb'];
        if (setupConfigs.mode !== 'real') {
            requiredBinaries.push('avdmanager', 'emulator');
        }
        const missingBinaries = this.checkBinariesPresent(requiredBinaries);
        missingRequirements.push(...missingBinaries);
        // check for build-tools
        if (this.options.appium) {
            const buildToolsPath = path_1.default.join(this.sdkRoot, 'build-tools');
            const availableVersions = (0, sdk_1.getBuildToolsAvailableVersions)(buildToolsPath);
            if (availableVersions.length > 0) {
                logger_1.default.log(`  ${ansi_colors_1.default.green((0, utils_1.symbols)().ok)} ${ansi_colors_1.default.cyan('Android Build Tools')} present at '${buildToolsPath}'.`, `Available versions: ${ansi_colors_1.default.cyan(availableVersions.join(', '))}\n`);
            }
            else {
                logger_1.default.log(`  ${ansi_colors_1.default.red((0, utils_1.symbols)().fail)} ${ansi_colors_1.default.cyan('Android Build Tools')} not present at '${buildToolsPath}'\n`);
                missingRequirements.push('build-tools');
            }
        }
        // check for platforms subdirectory (required by emulator)
        if (requiredBinaries.includes('emulator')) {
            const platormsPath = path_1.default.join(this.sdkRoot, 'platforms');
            if (fs_1.default.existsSync(platormsPath)) {
                logger_1.default.log(`  ${ansi_colors_1.default.green((0, utils_1.symbols)().ok)} ${ansi_colors_1.default.cyan('platforms')} subdirectory is present at '${platormsPath}'\n`);
            }
            else {
                logger_1.default.log(`  ${ansi_colors_1.default.red((0, utils_1.symbols)().fail)} ${ansi_colors_1.default.cyan('platforms')} subdirectory not present at '${platormsPath}'\n`);
                missingRequirements.push('platforms');
            }
            const avdPresent = this.verifyAvdPresent();
            if (avdPresent) {
                logger_1.default.log(`  ${ansi_colors_1.default.green((0, utils_1.symbols)().ok)} ${ansi_colors_1.default.cyan(constants_1.NIGHTWATCH_AVD)} AVD is present and ready to be used.\n`);
            }
            else {
                logger_1.default.log(`  ${ansi_colors_1.default.red((0, utils_1.symbols)().fail)} ${ansi_colors_1.default.cyan(constants_1.NIGHTWATCH_AVD)} AVD not found.\n`);
                missingRequirements.push(constants_1.NIGHTWATCH_AVD);
            }
        }
        const binariesPresent = requiredBinaries.filter((binary) => !missingBinaries.includes(binary));
        if (binariesPresent.length) {
            const nonWorkingBinaries = this.checkBinariesWorking(binariesPresent);
            missingRequirements.push(...nonWorkingBinaries);
        }
        if (missingRequirements.length === 0) {
            this.verifyAdbRunning();
        }
        return missingRequirements;
    }
    async setupAndroid(setupConfigs, missingRequirements) {
        if (setupConfigs.mode === 'real') {
            logger_1.default.log('Setting up missing requirements for real devices...\n');
        }
        else if (setupConfigs.mode === 'emulator') {
            logger_1.default.log('Setting up missing requirements for Android emulator...\n');
        }
        else {
            logger_1.default.log('Setting up missing requirements for real devices/emulator...\n');
        }
        // check if sdkmanager is present and working (below line will check both)
        logger_1.default.log('Verifying that sdkmanager is present and working...');
        const sdkManagerWorking = this.checkBinariesWorking(['sdkmanager']).length === 0;
        if (sdkManagerWorking) {
            logger_1.default.log(ansi_colors_1.default.green('Success!'), '\n');
        }
        if (!sdkManagerWorking || missingRequirements.includes('avdmanager')) {
            // remove avdmanager from missingRequirements to avoid double downloads.
            const avdmanagerIndex = missingRequirements.indexOf('avdmanager');
            if (avdmanagerIndex > -1) {
                missingRequirements.splice(avdmanagerIndex, 1);
            }
            logger_1.default.log('Downloading cmdline-tools...');
            await (0, sdk_1.downloadAndSetupAndroidSdk)(this.sdkRoot, this.platform);
        }
        const packagesToInstall = missingRequirements
            .filter((requirement) => Object.keys(constants_1.BINARY_TO_PACKAGE_NAME).includes(requirement))
            .map((binary) => constants_1.BINARY_TO_PACKAGE_NAME[binary]);
        // Update emulator as well
        if (setupConfigs.mode !== 'real' && !missingRequirements.includes('emulator')) {
            packagesToInstall.push(constants_1.BINARY_TO_PACKAGE_NAME['emulator']);
        }
        let result = (0, sdk_1.installPackagesUsingSdkManager)((0, common_1.getBinaryLocation)(this.sdkRoot, this.platform, 'sdkmanager', true), this.platform, packagesToInstall);
        // Download build-tools if using Appium
        if (this.options.appium) {
            const res = (0, sdk_1.downloadSdkBuildTools)((0, common_1.getBinaryLocation)(this.sdkRoot, this.platform, 'sdkmanager', true), this.platform);
            if (!res) {
                result = false;
            }
        }
        if (missingRequirements.includes('platforms')) {
            logger_1.default.log('Creating platforms subdirectory...');
            const platformsPath = path_1.default.join(this.sdkRoot, 'platforms');
            try {
                fs_1.default.mkdirSync(platformsPath);
                // eslint-disable-next-line
            }
            catch { }
            logger_1.default.log(`${ansi_colors_1.default.green('Success!')} Created platforms subdirectory at ${platformsPath}\n`);
        }
        if (missingRequirements.includes(constants_1.NIGHTWATCH_AVD)) {
            // Check if AVD is already created and only the system-image was missing.
            const avdPresent = this.verifyAvdPresent();
            if (!avdPresent) {
                logger_1.default.log(`Creating AVD "${constants_1.NIGHTWATCH_AVD}" using pixel_5 hardware profile...`);
                const avdCreated = (0, sdk_1.execBinarySync)((0, common_1.getBinaryLocation)(this.sdkRoot, this.platform, 'avdmanager', true), 'avdmanager', this.platform, `create avd --force --name "${constants_1.NIGHTWATCH_AVD}" --package "system-images;android-30;google_apis;${constants_1.ABI}" --device "pixel_5"`);
                if (avdCreated !== null) {
                    logger_1.default.log(`${ansi_colors_1.default.green('Success!')} AVD "${constants_1.NIGHTWATCH_AVD}" created successfully!\n`);
                }
                else {
                    logger_1.default.log();
                    result = false;
                }
            }
        }
        this.verifyAdbRunning();
        return result;
    }
    async verifyAndSetupBrowsers(browsersConfig) {
        const browsers = [];
        if (browsersConfig === 'both') {
            browsers.push('chrome', 'firefox');
        }
        else if (browsersConfig && browsersConfig !== 'none') {
            browsers.push(browsersConfig);
        }
        // add chrome for web-view testing on Android Emulator
        if (this.options.appium && !browsers.includes('chrome')) {
            browsers.push('chrome');
        }
        if (!browsers.length) {
            return true;
        }
        const status = {
            // verify true by default
            // (turn to false only when browser not found)
            verifyFirefox: true,
            verifyChrome: true,
            // setup false by default
            // (turn to true only when setup complete)
            setupFirefox: false,
            setupChrome: false
        };
        const verifyFirefox = browsers.includes('firefox');
        const verifyChrome = browsers.includes('chrome');
        let firefoxLatestVersion = '';
        let installedChromeVersion = '';
        let installFirefox = false;
        let downloadChromedriver = false;
        const chromedriverDownloadDir = path_1.default.join(this.rootDir, 'chromedriver-mobile');
        const chromedriverDownloadPath = path_1.default.join(chromedriverDownloadDir, (0, common_1.getBinaryNameForOS)(this.platform, 'chromedriver'));
        logger_1.default.log('Verifying if browser(s) are installed...\n');
        const emulatorAlreadyRunning = await (0, adb_1.getAlreadyRunningAvd)(this.sdkRoot, this.platform, constants_1.NIGHTWATCH_AVD);
        const emulatorId = emulatorAlreadyRunning || await (0, adb_1.launchAVD)(this.sdkRoot, this.platform, constants_1.NIGHTWATCH_AVD);
        if (!emulatorId) {
            logger_1.default.log('Please close the emulator manually if running and not closed automatically.\n');
            return false;
        }
        logger_1.default.log('Making sure adb has root permissions...');
        const adbRootStdout = (0, sdk_1.execBinarySync)((0, common_1.getBinaryLocation)(this.sdkRoot, this.platform, 'adb', true), 'adb', this.platform, `-s ${emulatorId} root`);
        if (adbRootStdout !== null) {
            logger_1.default.log(`  ${ansi_colors_1.default.green((0, utils_1.symbols)().ok)} adb is running with root permissions!\n`);
        }
        else {
            logger_1.default.log('Please try running the above command by yourself.\n');
        }
        if (verifyFirefox) {
            firefoxLatestVersion = await (0, common_1.getLatestVersion)('firefox');
            logger_1.default.log('Verifying if Firefox is installed...');
            const stdout = (0, sdk_1.execBinarySync)((0, common_1.getBinaryLocation)(this.sdkRoot, this.platform, 'adb', true), 'adb', this.platform, `-s ${emulatorId} shell pm list packages org.mozilla.firefox`);
            if (stdout) {
                logger_1.default.log(`  ${ansi_colors_1.default.green((0, utils_1.symbols)().ok)} Firefox browser is installed in the AVD.\n`);
                logger_1.default.log('Checking the version of installed Firefox browser...');
                const versionStdout = (0, sdk_1.execBinarySync)((0, common_1.getBinaryLocation)(this.sdkRoot, this.platform, 'adb', true), 'adb', this.platform, `-s ${emulatorId} shell dumpsys package org.mozilla.firefox`);
                if (versionStdout !== null) {
                    const versionMatch = versionStdout.match(/versionName=((\d+\.)+\d+)/);
                    if (!versionMatch) {
                        logger_1.default.log(`  ${ansi_colors_1.default.red((0, utils_1.symbols)().fail)} Failed to find the version of the Firefox browser installed.\n`);
                    }
                    else if (versionMatch[1] !== firefoxLatestVersion) {
                        const currentMajorVersion = parseInt(versionMatch[1].split('.')[0], 10);
                        const latestMajorVersion = parseInt(firefoxLatestVersion.split('.')[0], 10);
                        if (firefoxLatestVersion === constants_1.DEFAULT_FIREFOX_VERSION && currentMajorVersion >= latestMajorVersion) {
                            logger_1.default.log(`  ${ansi_colors_1.default.red((0, utils_1.symbols)().fail)} Failed to fetch the latest version of Firefox browser.\n`);
                        }
                        else {
                            logger_1.default.log(`  ${ansi_colors_1.default.yellow('!')} A new version of Firefox browser is available (${ansi_colors_1.default.cyan(versionMatch[1] + ' -> ' + firefoxLatestVersion)})\n`);
                            installFirefox = true;
                        }
                    }
                    else {
                        logger_1.default.log(`  ${ansi_colors_1.default.green((0, utils_1.symbols)().ok)} Your Firefox browser is up-to-date.\n`);
                    }
                }
                else {
                    logger_1.default.log('Could not get the version of the installed Firefox browser.\n');
                }
            }
            else if (stdout !== null) {
                logger_1.default.log(`  ${ansi_colors_1.default.red((0, utils_1.symbols)().fail)} Firefox browser not found in the AVD.\n`);
                installFirefox = true;
                status.verifyFirefox = false;
            }
            else {
                // Command failed.
                logger_1.default.log('Failed to verify the presence of Firefox browser.\n');
                status.verifyFirefox = false;
            }
        }
        if (verifyChrome) {
            logger_1.default.log('Verifying if Chrome is installed...');
            const stdout = (0, sdk_1.execBinarySync)((0, common_1.getBinaryLocation)(this.sdkRoot, this.platform, 'adb', true), 'adb', this.platform, `-s ${emulatorId} shell pm list packages com.android.chrome`);
            if (stdout) {
                logger_1.default.log(`  ${ansi_colors_1.default.green((0, utils_1.symbols)().ok)} Chrome browser is installed in the AVD.\n`);
                logger_1.default.log('Checking the version of installed Chrome browser...');
                const versionStdout = (0, sdk_1.execBinarySync)((0, common_1.getBinaryLocation)(this.sdkRoot, this.platform, 'adb', true), 'adb', this.platform, `-s ${emulatorId} shell dumpsys package com.android.chrome`);
                if (versionStdout !== null) {
                    const versionMatch = versionStdout.match(/versionName=((\d+\.)+\d+)/);
                    if (!versionMatch) {
                        logger_1.default.log(`  ${ansi_colors_1.default.red((0, utils_1.symbols)().fail)} Failed to find the version of the Chrome browser installed.\n`);
                    }
                    else {
                        logger_1.default.log(`Version: ${ansi_colors_1.default.green(versionMatch[1])}\n`);
                        installedChromeVersion = versionMatch[1];
                    }
                    logger_1.default.log(`${ansi_colors_1.default.bold('Note:')} Automatic upgrade of Chrome browser is not supported yet.\n`);
                    // Logger.log('You can upgrade the browser by using Play Store in the emulator if need be.');
                }
                else {
                    logger_1.default.log('Could not get the version of the installed Chrome browser.\n');
                }
                // TODO: add major version of Chrome as suffix to chromedriver.
                // Or, check the version of existing chromedriver using --version.
                if (!this.options.standalone) {
                    logger_1.default.log('Checking if chromedriver is already downloaded...');
                    if (fs_1.default.existsSync(chromedriverDownloadPath)) {
                        logger_1.default.log(`  ${ansi_colors_1.default.green((0, utils_1.symbols)().ok)} chromedriver already present at '${chromedriverDownloadPath}'\n`);
                    }
                    else {
                        logger_1.default.log(`  ${ansi_colors_1.default.red((0, utils_1.symbols)().fail)} chromedriver not found at '${chromedriverDownloadPath}'\n`);
                        downloadChromedriver = true;
                    }
                }
            }
            else if (stdout !== null) {
                logger_1.default.log(`  ${ansi_colors_1.default.red((0, utils_1.symbols)().fail)} Chrome browser not found in the AVD.\n`);
                logger_1.default.log(`${ansi_colors_1.default.yellow('Note:')} Automatic installation of Chrome browser is not supported yet.\n`);
                status.verifyChrome = false;
            }
            else {
                // Command failed.
                logger_1.default.log('Failed to verify the presence of Chrome browser.\n');
                status.verifyChrome = false;
            }
        }
        if (!this.options.setup) {
            let message = '';
            if (installFirefox && downloadChromedriver) {
                message = 'Do you wish to setup the missing browser requirements?';
            }
            else if (installFirefox) {
                message = 'Do you wish to install/upgrade the Firefox browser?';
            }
            else if (downloadChromedriver) {
                message = `Do you wish to setup the missing requirements for ${this.options.appium ? 'Appium' : 'Chrome browser'}?`;
            }
            if (message) {
                this.options.setup = await this.askToSetupAndroid(message);
            }
        }
        if (this.options.setup) {
            if (installFirefox) {
                logger_1.default.log('Downloading latest Firefox APK...');
                const firefoxDownloaded = await (0, common_1.downloadFirefoxAndroid)(firefoxLatestVersion);
                if (firefoxDownloaded) {
                    logger_1.default.log('\nInstalling the downloaded APK in the running AVD...');
                    const stdout = (0, sdk_1.execBinarySync)((0, common_1.getBinaryLocation)(this.sdkRoot, this.platform, 'adb', true), 'adb', this.platform, `-s ${emulatorId} install -r ${path_1.default.join(os_1.default.tmpdir(), (0, common_1.getFirefoxApkName)(firefoxLatestVersion))}`);
                    if (stdout !== null) {
                        logger_1.default.log(`  ${ansi_colors_1.default.green((0, utils_1.symbols)().ok)} Firefox browser installed successfully!\n`);
                        logger_1.default.log('You can run your tests now on your Android Emulator\'s Firefox browser.\n');
                        status.setupFirefox = true;
                    }
                    else {
                        logger_1.default.log('Please try running the above command by yourself (make sure that the emulator is running).\n');
                    }
                }
                else {
                    logger_1.default.log(`\n${ansi_colors_1.default.red('Failed!')} Please download the latest version of Firefox from the below link.`);
                    logger_1.default.log('(Drag-and-drop the downloaded APK over the emulator screen to install.)');
                    logger_1.default.log(ansi_colors_1.default.cyan('  https://archive.mozilla.org/pub/fenix/releases'), '\n');
                }
            }
            if (downloadChromedriver) {
                const chromeMajorVersion = installedChromeVersion.split('.')[0];
                if (constants_1.DEFAULT_CHROME_VERSIONS.includes(chromeMajorVersion)) {
                    logger_1.default.log('Downloading chromedriver to work with the factory version of Chrome browser...');
                    const chromedriverDownloadLink = downloads_json_1.default.chromedriver[chromeMajorVersion][this.platform];
                    const result = await (0, common_1.downloadWithProgressBar)(chromedriverDownloadLink, chromedriverDownloadDir, true);
                    if (result) {
                        logger_1.default.log(`${ansi_colors_1.default.green('Done!')} chromedriver downloaded at '${chromedriverDownloadPath}'\n`);
                        status.setupChrome = true;
                    }
                    else {
                        logger_1.default.log(`\n${ansi_colors_1.default.red('Failed!')} You can download the chromedriver yourself from the below link:`);
                        logger_1.default.log(ansi_colors_1.default.cyan(`  ${chromedriverDownloadLink}`));
                        logger_1.default.log('  (Extract and copy the chromedriver binary and paste it in your Nightwatch project inside \'chromedriver-mobile\' folder.)', '\n');
                    }
                    if (status.setupChrome) {
                        logger_1.default.log('You can run your tests now on your Android Emulator\'s Chrome browser.\n');
                    }
                }
                else if (installedChromeVersion === '') {
                    logger_1.default.log(ansi_colors_1.default.red((0, utils_1.symbols)().fail), 'chromedriver could not be downloaded (installed browser version unknown).\n');
                }
                else {
                    logger_1.default.log((0, boxen_1.default)(ansi_colors_1.default.cyan('[CHROMEDRIVER]\n\n') +
                        ansi_colors_1.default.red('Could not download chromedriver (installed Chrome version is different from the factory versions).\n\n') +
                        'You can download chromedriver for the installed Chrome version from the below link:\n' +
                        ansi_colors_1.default.cyan('  https://chromedriver.storage.googleapis.com/index.html\n\n') +
                        'After downloading, extract the zip file, copy the extracted chromedriver binary, and put in inside \'chromedriver-mobile\' folder in your Nightwatch project.', { padding: 1 }), '\n');
                }
            }
        }
        if (!emulatorAlreadyRunning) {
            logger_1.default.log('Closing emulator...');
            (0, adb_1.killEmulatorWithoutWait)(this.sdkRoot, this.platform, emulatorId);
            logger_1.default.log('Emulator will close shortly. If not, please close it manually.\n');
        }
        // below is true by default
        // will turn to false if some verify step has failed or chromedriver is needed to be downloaded
        // and for it to turn back to true, corresponding setup step should pass.
        // if chrome is not present, then we can't do anything but send out a warning/error.
        return (status.verifyFirefox || status.setupFirefox) && status.verifyChrome && (!downloadChromedriver || status.setupChrome);
    }
    postSetupInstructions(result, setupConfigs) {
        if (!this.options.setup) {
            if (result) {
                logger_1.default.log(`${ansi_colors_1.default.green('Great!')} All the requirements are being met.`);
                if (this.options.standalone) {
                    // Logs related to standalone mode to be added here.
                }
                else if (setupConfigs.mode === 'real') {
                    logger_1.default.log('You can go ahead and run your tests now on your Android device.\n');
                }
                else {
                    logger_1.default.log('You can go ahead and run your tests now on an Android device/emulator.\n');
                }
            }
            else {
                logger_1.default.log(`Please use ${ansi_colors_1.default.magenta('--setup')} flag with the command to install all the missing requirements.\n`);
            }
        }
        else {
            if (result) {
                logger_1.default.log(`${ansi_colors_1.default.green('Success!')} All requirements are set.`);
                if (this.options.standalone) {
                    // Logs related to standalone mode to be added here.
                }
                else if (setupConfigs.mode === 'real') {
                    logger_1.default.log('You can go ahead and run your tests now on your Android device.\n');
                }
                else {
                    logger_1.default.log('You can go ahead and run your tests now on an Android device/emulator.\n');
                }
            }
            else {
                logger_1.default.log(`${ansi_colors_1.default.red('Error:')} Some requirements failed to set up.`);
                logger_1.default.log('Please look for the errors above and try running any failed commands by yourself and then re-run this tool.\n');
                logger_1.default.log('If it still fails, please raise an issue with us at:');
                logger_1.default.log(ansi_colors_1.default.cyan('  https://github.com/nightwatchjs/mobile-helper-tool/issues'), '\n');
            }
        }
    }
    envSetInstructions(sdkRootEnv) {
        logger_1.default.log(ansi_colors_1.default.red('IMPORTANT'));
        logger_1.default.log(ansi_colors_1.default.red('---------'));
        if (!sdkRootEnv) {
            // ANDROID_HOME is either undefined or '' in system env and .env.
            if (this.otherInfo.androidHomeInGlobalEnv) {
                // ANDROID_HOME is set in system env, to ''.
                logger_1.default.log(`${ansi_colors_1.default.cyan('ANDROID_HOME')} env is set to '' which is NOT a valid path!\n`);
                logger_1.default.log(`Please set ${ansi_colors_1.default.cyan('ANDROID_HOME')} to '${this.sdkRoot}' in your system environment variables.`);
                logger_1.default.log('(As ANDROID_HOME is already set in system env, temporarily saving it to .env file won\'t work.)\n');
            }
            else {
                logger_1.default.log(`${ansi_colors_1.default.cyan('ANDROID_HOME')} env was temporarily saved in ${ansi_colors_1.default.cyan('.env')} file (set to '${this.sdkRoot}').\n`);
                logger_1.default.log(`Please set ${ansi_colors_1.default.cyan('ANDROID_HOME')} env to '${this.sdkRoot}' in your system environment variables and then delete it from ${ansi_colors_1.default.cyan('.env')} file.\n`);
            }
        }
        if (this.options.appium) {
            // JAVA_HOME env was not found and we set it ourselves in .env (javaHomeFound=null).
            // In case JAVA_HOME was found incorrect in system env (javaHomeFound=false),
            // process should have exited with error.
            logger_1.default.log(`${ansi_colors_1.default.cyan('JAVA_HOME')} env was temporarily saved in ${ansi_colors_1.default.cyan('.env')} file (set to '${this.javaHome}').\n`);
            logger_1.default.log(`Please set ${ansi_colors_1.default.cyan('JAVA_HOME')} env to '${this.javaHome}' in your system environment variables and then delete it from ${ansi_colors_1.default.cyan('.env')} file.\n`);
        }
        logger_1.default.log('Following the above instructions might save you from future troubles.\n');
        this.envSetHelp();
    }
    envSetHelp() {
        // Add platform-wise help or link a doc to help users set env variable.
    }
}
exports.AndroidSetup = AndroidSetup;
